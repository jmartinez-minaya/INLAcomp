---
title: "Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure"
author: "Joaquín Martínez-Minaya and Haavard Rue"
output: 
  # rmarkdown::html_vignette:
  bookdown::html_document2:
    df_print: paged
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache   = TRUE
)

```

```{r}
#Configuration for posterior sample
#For replicating
rm(list=ls())
set.seed(201803)
inla.seed = sample.int(n=1E6, size=1)
options(width=70, digits=7)

``` 

This document has been created with the purpose of showing how one can fit an LNDR model when dealing with compositional data.

```{r setup, warning = FALSE, message=FALSE}
library(INLAcomp)
library(sp)
library(ggplot2)
library(dplyr)
library(viridis)
library(INLA)
library(raster)
library(parallel)
```
# Functions for plotting
```{r}
  #' Include a suffix to variable names
#'
#' Used with \code{\link[INLA]{inla.stack}} for building effect stacks.
#'
#' @param x a data.frame
#' @param suffix character string to be appended to variable names
#' @param makeNA logical. If \code{TRUE}, returns the suffixed data.frame filled
#'   with \code{NA}.
#' @export
suffix <- function(x, suffix, makeNA = FALSE) {
  z <- structure(x, names = paste(names(x), suffix, sep = '.'))
  if(makeNA) z[] <- NA
  z
}

### --- function to convert matrix to raster --- ####
rotate <- function(x)(apply(x,2,rev))

matrix_to_raster <- function(m, proj.grid.mat = proj.grid.mat)
{
  raster(rotate(t(m)), 
         xmn = min(proj.grid.mat$lattice$loc[,1]), 
         xmx = max(proj.grid.mat$lattice$loc[,1]), 
         ymn = min(proj.grid.mat$lattice$loc[,2]), 
         ymx = max(proj.grid.mat$lattice$loc[,2]), 
         crs = proj4string(INLAcomp::polygon_IP))   
}

# Legend
g_legend <- function(a.gplot) {
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend) }


### 
raster_spatial_effect <- function(spatial, boundary, 
                                  boundary1 = INLAcomp::polygon_IP,
                                  rast = TRUE,
                                  res = c(5000, 5000))
{
  
  if(rast == TRUE){
    res <- res(raster_predict)
  }
  proj <- inla.mesh.projector(mesh,
                              xlim = bbox(boundary)[1,],
                              ylim = bbox(boundary)[2,],
                              dims = c(round((bbox(boundary)[1,"max"] - bbox(boundary)[1,"min"])/res[1],0),
                                       round((bbox(boundary)[2,"max"]-bbox(boundary)[2,"min"])/res[2],0)))
  
  if(length(spatial) == mesh$n)
  {
    field.proj = inla.mesh.project(proj, spatial[1:mesh$n])
    
    field1 <- matrix_to_raster(field.proj, proj.grid.mat = proj)
    field1 <- crop(field1, boundary)
    field1 <- mask(field1, boundary)
    #plot(field1)
  }else{
    res <- matrix(spatial, byrow = FALSE, ncol = k-1)
    total <- apply(res, 2,
                   function(x){
                     res1 <- inla.mesh.project(proj, x)
                     field1 <- matrix_to_raster(res1, proj.grid.mat = proj)
                     field1 <- crop(field1, boundary1)
                     field1 <- mask(field1, boundary1)
                     #plot(field1)
                     #field1
                   })
    field1 <- raster::stack(total)
  }
  field1
}


#Plotting rasters
plot_raster <- function(rast, cat, sc = FALSE, col1 = "G", ymin = 0, ymax = 1)
{
  sp_eus2 <- fortify(INLAcomp::polygon_IP_low)
  rast_gc1 <- as(rast[[cat]], "SpatialPixelsDataFrame")
  rast_gc1 <- as.data.frame(rast_gc1)
  colnames(rast_gc1) <- c("value", "x", "y")
  
  gc1_pred <- ggplot() +
    geom_tile(data = rast_gc1, aes(x = x, y = y, fill = value)) +
    geom_polygon(data = INLAcomp::polygon_IP_low, aes(x = long, y = lat, group = group),
                 fill = NA, color = "gray20", size = 0.25) +
    coord_equal(ratio = 1) +
    ggtitle(cat) +
    theme(line = element_blank(), # remove axis lines ..
          axis.text = element_blank(),                       # .. tickmarks..
          axis.title = element_blank(),
          panel.background = element_blank(),
          legend.position = "bottom",
          legend.key.height = unit(0.5, "cm"),
          legend.key.width = unit(4, "cm"),
          legend.title = element_blank(),
          legend.text = element_text(size = 16),
          plot.title = element_text(size = 17, hjust = 0.5)) +
    scale_fill_viridis(option = col1, direction = -1, limits = c(ymin, ymax)) 
  if(sc == TRUE)
  {
    
    gc1_pred <- gc1_pred +
  annotation_scale(location = "br", width_hint = 0.3, size = 4) +
  annotation_north_arrow(location = "br", which_north = "true", 
                         pad_x = unit(0.0, "in"), pad_y = unit(0.2, "in"),
                         style = north_arrow_fancy_orienteering)

  }
  gc1_pred
  
}

```

# Dataset 

## Loading the dataset

We load the data, and also the `SpatialPolygons` which contains the boundaries of the Iberian Peninsula. 

```{r}
data <- INLAcomp::arabidopsis
head(data)
```
```{r}
penin_2 <- INLAcomp::polygon_IP
plot(penin_2)
```


## We scale the covariates 

```{r}
  #We scale the covariates
bio_scaled <- data %>%
  dplyr::select(starts_with("bio")) %>%
  scale(.)

colnames(bio_scaled) <- paste0("sc_", colnames(bio_scaled ))
data <- cbind(data, bio_scaled)
data[, c("x", "y", paste0("sc_bio", c(1, 2, 3, 4, 8, 12, 15, 18)))]
```

## Covariates raster
```{r}
bio1 <- raster("../rasters/bio1.tif")
bio12 <- raster("../rasters/bio12.tif")



#It has different resolution to the one that we want to predict. We aggregate it
#Aggregating to 10x10km
bio1 <- raster::aggregate(bio1, fact = 5, fun = "mean")
bio12 <- raster::aggregate(bio12, fact = 5, fun = "mean")

#Scaled it
str(bio_scaled)
attr(bio_scaled,"scaled:center")["bio12"]
attr(bio_scaled, "scaled:scale")["bio12"]

# a <- (data$bio12 -attr(bio_scaled,"scaled:center")["bio12"])/attr(bio_scaled, "scaled:scale")["bio12"]
# 
# round(a, 8) == round(bio_scaled[,"sc_bio12"],8)

sc_bio1 <- (bio1 - attr(bio_scaled,"scaled:center")["bio1"])/attr(bio_scaled,"scaled:scale")["bio1"]
sc_bio12 <- (bio12 - attr(bio_scaled,"scaled:center")["bio12"])/attr(bio_scaled,"scaled:scale")["bio12"]

par(mfrow=c(1,2))
plot(sc_bio1)
plot(sc_bio12)


```

## Plotting the response

```{r}
penin_2_fort <- fortify(penin_2)

data_plot <- data %>%
  dplyr::select(x, y, gc1, gc2, gc3, gc4) %>%
  tidyr::pivot_longer(all_of(paste0("gc", 1:4)))

p1 <- ggplot(data_plot) +
  geom_polygon(data = penin_2_fort, aes(x = long,
                                        y = lat,
                                        group = group),
               colour = 'gray70', fill = 'gray90')  +
  geom_point(data = data_plot,
             aes(x = x,
                 y = y,
                 #size = value,
                 color = value),
             alpha = 0.8, size = 2) +
  coord_fixed(ratio = 1) +
  facet_wrap(~ name, ncol = 4) +
  theme_bw() +
  theme(line = element_blank(),                          # remove axis lines ..
        axis.text = element_blank(),                       # .. tickmarks..
        axis.title = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom",
        legend.key.height = unit(0.5, "cm"),
        legend.key.width = unit(1.5, "cm"),
        legend.title = element_text(size = 17),
        legend.text = element_text(size = 15),
        strip.text = element_text(size = 15)) +
  #guides(fill = guide_legend(title.position="top", title.hjust = 0.5)) +
  xlab("") +
  ylab("") +
  scale_color_viridis(option="magma", direction = -1, limits = c(0, 1),
                      name = "") 
#pdf("arabidopsis_des.pdf", width = 12, height = 4)
print(p1)
#dev.off()
```

## `alr` transformation

We conduct the `alr`transformation, but, which category should be chosen as reference? The one with lowest variance. Also the one that has low variability. In this case, GC4.

```{r}
data %>% dplyr::select(gc1, gc2, gc3, gc4) %>%
  apply(., 2, function(x){var(log(x))})
#Also that they don't have so small values
data %>% 
  tidyr::pivot_longer(., cols = all_of(paste0("gc", 1:4)), 
                      names_to  = "gc",
                      values_to = "val_gc") %>%
  ggplot(data = .) +
  geom_density(aes(x = val_gc, fill = gc), alpha = 0.4) +
  theme_bw() +
  theme(legend.position = "bottom") +
  xlab("Membership probability to GC") +
  ylab("Density")

### Reference category is gc4. 
n <- dim(data)[1]
k <- 4
result_order <- c(paste0("gc", 1:k))
ref_cat <- paste0("gc", k)

names_gc <- c(result_order[!(result_order %in% ref_cat)])
result_order <- c(names_gc, ref_cat)


data <- cbind(data, 
              alr = compositions::alr(data[, result_order]))

data[, c("x", "y", paste0("sc_bio", c(1, 2, 3, 4, 8, 12, 15, 18)), paste0("alr.gc", 1:3))]
```

```{r}

### ----- 2.4. Descriptive map alr --- ####
data_plot_alr <- data %>%
  dplyr::select(all_of(c("x", "y", paste0("alr.", names_gc)))) %>%
  tidyr::pivot_longer(all_of(paste0("alr.", names_gc)))

#Plotting the map
p2 <- ggplot(data_plot_alr) +
  geom_polygon(data = penin_2_fort, aes(x = long,
                                        y = lat,
                                        group = group),
               colour = 'gray70', fill = 'gray90')  +
  geom_point(data = data_plot_alr,
             aes(x = x,
                 y = y,
                 #size = value,
                 color = value),
             alpha = 0.8, size = 2) +
  coord_fixed(ratio = 1) +
  facet_wrap(~ name) +
  theme_bw() +
  theme(line = element_blank(),                          # remove axis lines ..
        axis.text = element_blank(),                       # .. tickmarks..
        axis.title = element_blank(),
        panel.background = element_blank(),
        legend.position = "bottom",
        legend.key.height = unit(0.5, "cm"),
        legend.key.width = unit(1.5, "cm"),
        legend.title = element_text(size = 17),
        legend.text = element_text(size = 15),
        strip.text = element_text(size = 15)) +
  #guides(fill = guide_legend(title.position="top", title.hjust = 0.5)) +
  xlab("") +
  ylab("") +
  scale_color_viridis(option="magma", direction = -1,
                      name = "") 
#pdf("arabidopsis_des_alr.pdf", width = 10, height = 4)
print(p2)
#dev.off()
```

# Preparing the data for fitting {.tabset}

## Defining a new column with the values of all `alr` coordinates
```{r}
data_ext <- data %>% 
  tidyr::pivot_longer(., cols = all_of(paste0("alr.", names_gc)), 
                      names_to  = "alr_gc",
                      values_to = "val_alr_gc") %>%
  .[order(ordered(.$alr_gc)),]
head(data_ext[, c("x", "y", "alr_gc", "val_alr_gc")])
```


## Defining index for indiciating which alr-coordinate are we dealing with

```{r}
data_ext$alr_gc <- ordered(data_ext$alr_gc)
k.group <- data_ext$alr_gc %>% as.numeric() #For group
k.repl  <- data_ext$alr_gc %>% as.numeric() #For replication
head(data.frame(k.group, k.repl))

```

## The mesh 
We create the mesh as we usually do in **R-INLA** for spatial effects.

```{r}
penin_inla <- inla.sp2segment(INLAcomp::polygon_IP_low)
mesh <- inla.mesh.2d(boundary = penin_inla,
                     max.edge = c(40000, 100000),
                     cutoff   = 30000,
                     min.angle= 30,
                     offset   = c(10000, 300000))
```

```{r}
plot(penin_2, xlim = c(mesh$loc[,1] %>% range()),
     ylim = c(mesh$loc[,2] %>% range(.)))
plot(mesh, add = TRUE)
points(data[,c("x", "y")], pch = 20)
```


## Defining the spde {.tabset} 

### Defining spde with priors

We use PC-priors for defining the spde object.

```{r}
size <- min(c(diff(range(penin_inla$loc[,1])), diff(range(penin_inla$loc[,2]))))
range0 <- size / 4 	# ~ default
spde <- inla.spde2.pcmatern(mesh        = mesh, 
                            prior.range = c(range0, 0.25), # P(range < range0) = 0.25
                            prior.sigma = c(1, 0.01)) # P(sigma > 1) = 0.01
```

### Index for the spatial effects {.tabset}
We distinguish if we copy the spatial effecto or we replicate it.



#### Spatial index to be used in the model. We define it by alr-coordinate

This spatial index is useful when we replicate spatial effects, in other words, when we have one spatial effect per linear predictor whose realizations are different and hyperparameters are equal.

```{r}
iset <- inla.spde.make.index('i', n.spde = spde$n.spde,
                             n.repl  = k-1) #Replicating spatial effect
```
#### This iset is for copy
This spatial index is useful when we copy spatial effects, in other words, when we have one spatial effect per linear predictor whose realizations are equal or proportionally equivalente, and hyperparameters are equal.

```{r}
iset2 <- inla.spde.make.index('i', n.spde = spde$n.spde)
iset_aux <- matrix(NA, ncol = k-1, nrow = k-1)
diag(iset_aux) <- rep(1, k-1)
iset2 <- kronecker(iset_aux, iset2$i)
colnames(iset2) <- paste0("iset.alr", 1:(k-1))
```

### Defining the projection matrix
```{r}
A.est <- inla.spde.make.A(mesh  = mesh,
                          loc   = cbind(data_ext$x, data_ext$y), 
                          repl  = k.repl) 
A.est2 <- A.est
```

## Defining the corresponding part to the shared random effect {.tabset}

### Index for the random effect that is going to give the correlation
```{r}
id.z <- rep(1:(dim(data_ext)[1]/(k-1)), k-1)
id.z
```

### Index for indicating the alr coordinate
```{r}
id.cat <- rep(1:(k-1), rep(n, k-1))
```

## Defining the `inla.stack`{.tabset}


### Response

We define a list with three elements (three alr-coordinates) in the format that **R-INLA** uses when deal with several likelihoods.

```{r}
#Response
names_alr <- paste0("alr.", names_gc)


1:length(names_alr) %>%
  lapply(., function(i){
    data_ext %>% 
      dplyr::filter(alr_gc == names_alr[i]) -> data_comp_i
    #Response
    y_alr <- matrix(ncol = names_alr %>% length(.), nrow = dim(data_comp_i)[1])
    y_alr[, i] <- data_comp_i$val_alr_gc
  }) -> y_alr

1:length(names_alr) %>%
  lapply(., function(i){
    y_aux <- data_ext %>%
      dplyr::select(val_alr_gc, alr_gc) %>%
      dplyr::filter(alr_gc == names_alr[i]) %>%
      dplyr::select(val_alr_gc) %>%
      as.matrix(.)
    aux_vec <- rep(NA, k-1)
    aux_vec[i] <- 1
    kronecker(aux_vec, y_aux)
  }) -> y_alr_list

y_alr <- do.call(cbind, y_alr_list)
y_alr[1:10,]

```

### Covariates
Covariates are going to be included in the model as random effects with big variance. So, we need the values of the covariates (the scaled one), and also, an index indicating to which alr-coordinate it belongs.

```{r}
variables <- c("intercept", data %>% 
                 dplyr::select(starts_with("sc_")) %>% 
                 colnames(.))
id.names <- paste0("id.", variables)
id.variables <- rep(id.cat, length(variables)) %>% 
  matrix(., ncol = length(variables), byrow = FALSE)
colnames(id.variables) <- id.names
```



### Inla stack for estimation
```{r}
stk.est <- inla.stack(data    = list(resp = y_alr),
                      A       = list(A.est, 1, A.est2),
                      effects = list(c(iset),
                                     #list(intercept = 1)), 
                                     cbind(data_ext %>% 
                                             dplyr::select(starts_with("sc_bio")),
                                           #cbind(data_ext[,c(paste0("bio", c(1,2)))],
                                           id.z,
                                           id.variables, 
                                           intercept = 1),
                                     data.frame(iset2)),
                      # data.frame(i.alr1 = iset,
                      #            i.alr2 = iset,
                      #            i.alr3 = iset)),
                      tag     = 'est')
```






# Fitting the different models {.tabset}

## Type I

Share the same parameters for fixed effects, and do not include spatial random e↵ects.

### Fitting the model 
```{r}
list_prior <- rep(list(list(prior = "pc.prec", param = c(1, 0.01))), k-1)

formula.typeI <- resp ~ -1 + 
  intercept + 
  sc_bio1 +
  sc_bio12 +
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))), constr = TRUE)

model.typeI <- inla(formula.typeI,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,   
                   verbose = FALSE)
```

### Posterior distribution of the fixed effects
```{r}
data_fixed <- rbind(data.frame(inla.smarginal(model.typeI$marginals.fixed$sc_bio1), var = "BIO1"),
                    data.frame(inla.smarginal(model.typeI$marginals.fixed$sc_bio12), var = "BIO12"))

p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  xlab(expression(beta)) +
  ylab(expression(p(beta *'|'* theta))) +
  theme(legend.title = element_blank())

p_fixed
```


### Posterior distribution for the spatial effect
There is no spatial effect in this model


### Posterior distribution of the hyperparameters
```{r}
### ------- 7.1.4. Posterior distributions of the hyperparameters --- ####
prec <- list(sigma2.1 = model.typeI$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeI$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeI$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeI$marginals.hyper$`Precision for id.z`)

hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })
names(hyper) <- names(prec)

hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>% 
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma"))

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma"))

p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",              labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

print(p.hyper)
```


## Type II

Have different parameters for fixed effects, and do not include spatial random e↵ects.

### Fitting the model 
```{r}
formula.typeII <- resp ~ -1 + 
  f(id.intercept, intercept,
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.sc_bio1, sc_bio1, #BIO1
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.sc_bio12, sc_bio12, #bio12
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))), constr = TRUE)

model.typeII <- inla(formula.typeII,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,   
                   verbose = FALSE)

```

### Posterior distribution of the fixed effects
```{r, fig.asp=0.5}
data_fixed <- rbind(data.frame(inla.smarginal(model.typeII$marginals.random$id.sc_bio1$index.1), alr = "alr.gc1", 
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeII$marginals.random$id.sc_bio1$index.2), alr = "alr.gc2",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeII$marginals.random$id.sc_bio1$index.3), alr = "alr.gc3",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeII$marginals.random$id.sc_bio12$index.1), alr = "alr.gc1",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeII$marginals.random$id.sc_bio12$index.2), alr = "alr.gc2",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeII$marginals.random$id.sc_bio12$index.3), alr = "alr.gc3",
                               var = "BIO12"))
p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  facet_wrap(~alr, nrow = 1) +
  xlab(expression(beta^(d))) +
  ylab(expression(p(beta^(d) *'|'* theta))) +
  theme(legend.title = element_blank())

p_fixed
```


### Posterior distribution for the spatial effect
There is no spatial effects


### Posterior distribution of the hyperparameters
```{r}
prec <- list(sigma2.1 = model.typeII$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeII$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeII$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeII$marginals.hyper$`Precision for id.z`)

hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })
names(hyper) <- names(prec)
hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>% 
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma", "phi", "sigma.sp"))

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma", "phi", "sigma.sp"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma", "phi", "sigma[w]"))

p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",              labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

print(p.hyper)
```

## Type III
Share the same parameters for fixed effects, and share the same spatial effect.


### Fitting the model 
```{r}
formula.typeIII <- resp ~ -1 + 
  intercept + 
  sc_bio1 +
  sc_bio12 +
  f(iset.alr1, model = spde) +
  f(iset.alr2, copy = "iset.alr1", 
    fixed = TRUE) +
  f(iset.alr3, copy = "iset.alr1", 
    fixed = TRUE) +  
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))), constr = TRUE)

model.typeIII <- inla(formula.typeIII,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,   
                   verbose = FALSE)

```

### Posterior distribution of the fixed effects
```{r}
data_fixed <- rbind(#data.frame(inla.smarginal(model.typeI$marginals.fixed$intercept), var = "Intercept"),
                    data.frame(inla.smarginal(model.typeIII$marginals.fixed$sc_bio1), var = "BIO1"),
                    data.frame(inla.smarginal(model.typeIII$marginals.fixed$sc_bio12), var = "BIO12"))

p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  xlab(expression(beta)) +
  ylab(expression(p(beta *'|'* theta))) +
  theme(legend.title = element_blank())

p_fixed
```


### Posterior distribution for the spatial effect
```{r, results='hide'}
raster_predict <- INLAcomp::raster_predict

spatial_mean <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeIII$summary.random[[c(a)]][['mean']],
                                      boundary = raster_predict)
})


spatial_sd <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeIII$summary.random[[a]]$sd,
                                    boundary = raster_predict)
})
```


```{r}
par(mfrow = c(2,3))
plot(spatial_mean[[1]], main = "Mean")
plot(spatial_mean[[2]], main = "Mean")
plot(spatial_mean[[3]], main = "Mean")

plot(spatial_sd[[1]], main = "Sd")
plot(spatial_sd[[2]], main = "Sd")
plot(spatial_sd[[3]], main = "Sd")
```


### Posterior distribution of the hyperparameters
```{r}
prec <- list(sigma2.1 = model.typeIII$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeIII$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeIII$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeIII$marginals.hyper$`Precision for id.z`)

hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })
names(hyper) <- names(prec)
hyper <- c(hyper, 
           sigma.sp = list(inla.smarginal(model.typeIII$marginals.hyperpar[["Stdev for iset.alr1"]])),
           phi = list(inla.smarginal(model.typeIII$marginals.hyperpar[["Range for iset.alr1"]])))
hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>% 
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma", "phi", "sigma.sp"))


hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma", "phi", "sigma.sp"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma", "phi", "sigma[w]"))


p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",              labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

print(p.hyper)
```

## Type IV
Have different parameters for fixed effects, and share the same spatial effect.

### Fitting the model 
```{r}
list_prior <- rep(list(list(prior = "pc.prec", param = c(1, 0.01))), k-1)

formula.typeIV <- resp ~ -1 + 
  f(id.intercept, intercept,
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.sc_bio1, sc_bio1, #BIO1
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.sc_bio12, sc_bio12, #bio12
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(iset.alr1, model = spde) +
  f(iset.alr2, copy = "iset.alr1", 
    fixed = TRUE) +
  f(iset.alr3, copy = "iset.alr1", 
    fixed = TRUE) + 
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))),
    constr = TRUE)

model.typeIV <- inla(formula.typeIV,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,   
                   verbose = FALSE)




```

### Posterior distribution of the fixed effects
```{r, fig.asp=0.5}
##Bio12
data_fixed <- rbind(data.frame(inla.smarginal(model.typeIV$marginals.random$id.sc_bio1$index.1), alr = "alr.gc1", 
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeIV$marginals.random$id.sc_bio1$index.2), alr = "alr.gc2",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeIV$marginals.random$id.sc_bio1$index.3), alr = "alr.gc3",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeIV$marginals.random$id.sc_bio12$index.1), alr = "alr.gc1",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeIV$marginals.random$id.sc_bio12$index.2), alr = "alr.gc2",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeIV$marginals.random$id.sc_bio12$index.3), alr = "alr.gc3",
                               var = "BIO12"))
p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  facet_wrap(~alr, nrow = 1) +
  xlab(expression(beta^(d))) +
  ylab(expression(p(beta^(d) *'|'* theta))) +
  theme(legend.title = element_blank())

p_fixed
```


### Posterior distribution for the spatial effect
```{r, results='hide'}
raster_predict <- INLAcomp::raster_predict

spatial_mean <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeIV$summary.random[[c(a)]][['mean']],
                                      boundary = raster_predict)
})


spatial_sd <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeIV$summary.random[[a]]$sd,
                                    boundary = raster_predict)
})
```


```{r}
par(mfrow = c(2,3))
plot(spatial_mean[[1]], main = "Mean")
plot(spatial_mean[[2]], main = "Mean")
plot(spatial_mean[[3]], main = "Mean")

plot(spatial_sd[[1]], main = "Sd")
plot(spatial_sd[[2]], main = "Sd")
plot(spatial_sd[[3]], main = "Sd")
```


### Posterior distribution of the hyperparameters
```{r}
### ------- 7.1.4. Posterior distributions of the hyperparameters --- ####
prec <- list(sigma2.1 = model.typeIV$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeIV$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeIV$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeIV$marginals.hyperpar$`Precision for id.z`)


hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })

names(hyper) <- names(prec)
hyper <- c(hyper,
           sigma.sp = list(inla.smarginal(model.typeIV$marginals.hyperpar[["Stdev for iset.alr1"]])),
           phi = list(inla.smarginal(model.typeIV$marginals.hyperpar[["Range for iset.alr1"]])))
hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>%
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma", "phi", "sigma.sp"))

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma", "phi", "sigma.sp"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma", "phi", "sigma[w]"))

p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",              labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

print(p.hyper)
```






## Type V

Share the same parameters for fixed effects, and the spatial effects between linear predictors are proportional.

### Fitting the model 
```{r}
formula.typeV <- resp ~ -1 + 
  intercept + 
  sc_bio1 +
  sc_bio12 +
  f(iset.alr1, model = spde) +
  f(iset.alr2, copy = "iset.alr1", 
    fixed = FALSE) +
  f(iset.alr3, copy = "iset.alr1", 
    fixed = FALSE) +  
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))), constr = TRUE)

model.typeV <- inla(formula.typeV,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,   
                   verbose = FALSE)

```

### Posterior distribution of the fixed effects
```{r}
data_fixed <- rbind(#data.frame(inla.smarginal(model.typeI$marginals.fixed$intercept), var = "Intercept"),
                    data.frame(inla.smarginal(model.typeV$marginals.fixed$sc_bio1), var = "BIO1"),
                    data.frame(inla.smarginal(model.typeV$marginals.fixed$sc_bio12), var = "BIO12"))

p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  xlab(expression(beta)) +
  ylab(expression(p(beta *'|'* theta))) +
  theme(legend.title = element_blank())

p_fixed
```


### Posterior distribution for the spatial effect
```{r, results='hide'}
raster_predict <- INLAcomp::raster_predict

spatial_mean <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeV$summary.random[[c(a)]][['mean']],
                                      boundary = raster_predict)
})


spatial_sd <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeV$summary.random[[a]]$sd,
                                    boundary = raster_predict)
})
```


```{r}
par(mfrow = c(2,3))
plot(spatial_mean[[1]], main = "Mean")
plot(spatial_mean[[2]], main = "Mean")
plot(spatial_mean[[3]], main = "Mean")

plot(spatial_sd[[1]], main = "Sd")
plot(spatial_sd[[2]], main = "Sd")
plot(spatial_sd[[3]], main = "Sd")
```


### Posterior distribution of the hyperparameters
```{r}
### ------- 7.1.4. Posterior distributions of the hyperparameters --- ####
prec <- list(sigma2.1 = model.typeV$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeV$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeV$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeV$marginals.hyper$`Precision for id.z`)

hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })
names(hyper) <- names(prec)
hyper <- c(hyper, 
           sigma.sp = list(inla.smarginal(model.typeV$marginals.hyperpar[["Stdev for iset.alr1"]])),
           phi = list(inla.smarginal(model.typeV$marginals.hyperpar[["Range for iset.alr1"]])),
           alpha1 = list(inla.smarginal(model.typeV$marginals.hyperpar[["Beta for iset.alr2"]])),
           alpha2 = list(inla.smarginal(model.typeV$marginals.hyperpar[["Beta for iset.alr3"]])))




hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>% 
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma", "phi", "sigma.sp", "alpha1", "alpha2"))

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma", "phi", "sigma.sp", "alpha1", "alpha2"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma", "phi", "sigma[w]", "alpha[1]", "alpha[2]"))
                          
p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",              labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

print(p.hyper)
```


## Type VI 

Have different parameters for fixed effects, and the spatial effects between linear predictors are proportional

### Fitting the model 
```{r}
list_prior <- rep(list(list(prior = "pc.prec", param = c(1, 0.01))), k-1)

formula.typeVI <- resp ~ -1 + 
 #intercept + 
    f(id.intercept, intercept,
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE,
    constr = TRUE) +
  f(id.sc_bio1, sc_bio1, #bio1
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.sc_bio12, sc_bio12, #bio12
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(iset.alr1, model = spde) +
  f(iset.alr2, copy = "iset.alr1",
    hyper = list(beta = list(fixed = FALSE, params = c(0, 1)))) +
  f(iset.alr3, copy = "iset.alr1",
         hyper = list(beta = list(fixed = FALSE, params = c(0, 1)))) +
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))),
    constr = TRUE)

# stk.est$A %>% dim(.)
# stk.est$effects$data$id.intercept %>% table(.)
# int1 <- int2 <- int3 <- stk.est$effects$data$id.intercept
# 
# int1[which(int1!= 1)] <- NA
# int2[which(int1!= 2)] <- NA
# int3[which(int1!= 3)] <- NA
# A <- matrix(stk.est$effects$data$sc_bio8)
# 
# A <- matrix(data$sc_bio8, ncol = 1)


# 
# A.int <- matrix(rep(1, 301), ncol = 1)
#   
# e <- rep(0, 1)
# dim(A.int)

model.typeVI <- inla(formula.typeVI,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,  
                   verbose = FALSE)

model.typeVI <- inla.rerun(model.typeVI)
summary(model.typeVI)
-mean(log(model.typeVI$cpo$cpo))

```

### Posterior distribution of the fixed effects
```{r, fig.asp=0.5}
  ### ----- 7.1. Posterior distributions of fixed effects and hyperpars --- ####
### ------- 7.1.1. Fixed effects --- ####
##Bio12
data_fixed <- rbind(data.frame(inla.smarginal(model.typeVI$marginals.random$id.sc_bio1$index.1), alr = "alr.gc1", 
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeVI$marginals.random$id.sc_bio1$index.2), alr = "alr.gc2",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeVI$marginals.random$id.sc_bio1$index.3), alr = "alr.gc3",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeVI$marginals.random$id.sc_bio12$index.1), alr = "alr.gc1",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeVI$marginals.random$id.sc_bio12$index.2), alr = "alr.gc2",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeVI$marginals.random$id.sc_bio12$index.3), alr = "alr.gc3",
                               var = "BIO12"))
p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  facet_wrap(~alr, nrow = 1) +
  xlab(expression(beta^(d))) +
  ylab(expression(p(beta^(d) *'|'* theta))) +
  theme(legend.title = element_blank())

p_fixed
```


### Posterior distribution for the spatial effect
```{r, results='hide'}
raster_predict <- INLAcomp::raster_predict

spatial_mean <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeVI$summary.random[[c(a)]][['mean']],
                                      boundary = raster_predict)
})


spatial_sd <- lapply(paste0("iset.alr", 1:3), function(a){
  raster_spatial_effect(spatial = model.typeVI$summary.random[[a]]$sd,
                                    boundary = raster_predict)
})
```


```{r}
par(mfrow = c(2,3))
plot(spatial_mean[[1]], main = "Mean")
plot(spatial_mean[[2]], main = "Mean")
plot(spatial_mean[[3]], main = "Mean")

plot(spatial_sd[[1]], main = "Sd")
plot(spatial_sd[[2]], main = "Sd")
plot(spatial_sd[[3]], main = "Sd")
```


### Posterior distribution of the hyperparameters
```{r}
prec <- list(sigma2.1 = model.typeVI$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeVI$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeVI$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeVI$marginals.hyper$`Precision for id.z`)

hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })
names(hyper) <- names(prec)
hyper <- c(hyper, 
           sigma.sp = list(inla.smarginal(model.typeVI$marginals.hyperpar[["Stdev for iset.alr1"]])),
           phi = list(inla.smarginal(model.typeVI$marginals.hyperpar[["Range for iset.alr1"]])),
           alpha1 = list(inla.smarginal(model.typeVI$marginals.hyperpar[["Beta for iset.alr2"]])),
          alpha2 = list(inla.smarginal(model.typeVI$marginals.hyperpar[["Beta for iset.alr3"]])))




hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>% 
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma", "phi", "sigma.sp", "alpha1", "alpha2"))

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma", "phi", "sigma.sp", "alpha1", "alpha2"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma", "phi", "sigma[w]", "alpha[1]", "alpha[2]"))

p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",              labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

print(p.hyper)
```



## Type VII

Share the same parameters for fixed effects, and different realisations of the spatial effect for each linear predictor

### Fitting the model 
```{r}
formula.typeVII <- resp ~ -1 + 
  intercept + 
  sc_bio1 +
  sc_bio12 +
  f(i,
    model = spde,
    replicate = i.repl) +
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))), constr = TRUE)

model.typeVII <- inla(formula.typeVII,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,   
                   verbose = FALSE)

```

### Posterior distribution of the fixed effects
```{r}
data_fixed <- rbind(#data.frame(inla.smarginal(model.typeI$marginals.fixed$intercept), var = "Intercept"),
                    data.frame(inla.smarginal(model.typeVII$marginals.fixed$sc_bio1), var = "BIO1"),
                    data.frame(inla.smarginal(model.typeVII$marginals.fixed$sc_bio12), var = "BIO12"))

p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  xlab(expression(beta)) +
  ylab(expression(p(beta *'|'* theta))) +
  theme(legend.title = element_blank())

p_fixed
```


### Posterior distribution for the spatial effect
```{r, results='hide'}
raster_predict <- INLAcomp::raster_predict

spatial_mean <- raster_spatial_effect(spatial = model.typeVII$summary.random[['i']][['mean']],
                                      boundary = raster_predict)


spatial_sd <- raster_spatial_effect(spatial = model.typeVII$summary.random[['i']]$sd,
                                    boundary = raster_predict)
```


```{r}
par(mfrow = c(2,3))
plot(spatial_mean[[1]], main = "Mean")
plot(spatial_mean[[2]], main = "Mean")
plot(spatial_mean[[3]], main = "Mean")

plot(spatial_sd[[1]], main = "Sd")
plot(spatial_sd[[2]], main = "Sd")
plot(spatial_sd[[3]], main = "Sd")
```


### Posterior distribution of the hyperparameters
```{r}
### ------- 7.1.4. Posterior distributions of the hyperparameters --- ####
prec <- list(sigma2.1 = model.typeVII$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeVII$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeVII$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeVII$marginals.hyper$`Precision for id.z`)

hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })
names(hyper) <- names(prec)
hyper <- c(hyper, 
           sigma.sp = list(inla.smarginal(model.typeVII$marginals.hyperpar[["Stdev for i"]])),
           phi = list(inla.smarginal(model.typeVII$marginals.hyperpar[["Range for i"]])))
hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>% 
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma", "phi", "sigma.sp"))
hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma", "phi", "sigma.sp"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma", "phi", "sigma[w]"))

p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",              labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

print(p.hyper)
```


## Type VIII 

Have different parameters for fixed effects, and different realisations of the spatial effect for each linear predictor

### Fitting the model 
```{r}
list_prior <- rep(list(list(prior = "pc.prec", param = c(1, 0.01))), k-1)

formula.typeVIII <- resp ~ -1 + 
  f(id.intercept, intercept,
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.sc_bio1, sc_bio1, #BIO1
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(id.sc_bio12, sc_bio12, #bio12
    model   = "iid",
    initial = log(1/1000),
    fixed   = TRUE) +
  f(i,
    model = spde,
    replicate = i.repl) +
  f(id.z,
    model = "iid",
    hyper = list(prec = list(prior = "pc.prec",
                             param = c(1, 0.01))), constr = TRUE)

model.typeVIII <- inla(formula.typeVIII,
                   family         = rep("gaussian", k - 1),
                   data           = inla.stack.data(stk.est),
                   control.compute = list(config = TRUE, 
                                          dic  = TRUE,
                                          waic = TRUE,
                                          cpo  = TRUE),
                   control.predictor = list(A = inla.stack.A(stk.est), 
                                            compute = TRUE),
                   control.family = list_prior,   
                   verbose = FALSE)

```

### Posterior distribution of the fixed effects
```{r, fig.asp=0.5}
  ### ----- 7.1. Posterior distributions of fixed effects and hyperpars --- ####
### ------- 7.1.1. Fixed effects --- ####
##Bio12
data_fixed <- rbind(data.frame(inla.smarginal(model.typeVIII$marginals.random$id.sc_bio1$index.1), alr = "alr.gc1", 
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeVIII$marginals.random$id.sc_bio1$index.2), alr = "alr.gc2",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeVIII$marginals.random$id.sc_bio1$index.3), alr = "alr.gc3",
                               var = "BIO1"),
                    data.frame(inla.smarginal(model.typeVIII$marginals.random$id.sc_bio12$index.1), alr = "alr.gc1",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeVIII$marginals.random$id.sc_bio12$index.2), alr = "alr.gc2",
                               var = "BIO12"),
                    data.frame(inla.smarginal(model.typeVIII$marginals.random$id.sc_bio12$index.3), alr = "alr.gc3",
                               var = "BIO12"))
p_fixed <- ggplot() +
  geom_line(data = data_fixed, aes(x = x, y = y, col = var, linetype = var), size = 0.9) +
  #ggtitle("Effect of the covariate bio12") +
  theme_bw() +
  scale_color_manual(values=c("#E75F00", "#56B4E9"))+
  theme(legend.position = "bottom") +
  facet_wrap(~alr, nrow = 1) +
  xlab(expression(beta^(d))) +
  ylab(expression(p(beta^(d) *'|'* theta))) +
  theme(legend.title = element_blank())


inla.pmarginal(0, model.typeVIII$marginals.random$id.sc_bio1$index.1)
inla.pmarginal(0, model.typeVIII$marginals.random$id.sc_bio1$index.2)
inla.pmarginal(0, model.typeVIII$marginals.random$id.sc_bio1$index.3)
inla.pmarginal(0, model.typeVIII$marginals.random$id.sc_bio12$index.1)
inla.pmarginal(0, model.typeVIII$marginals.random$id.sc_bio12$index.2)
inla.pmarginal(0, model.typeVIII$marginals.random$id.sc_bio12$index.3)


1- exp(model.typeVIII$summary.random$id.sc_bio1$mean)
1-exp(model.typeVIII$summary.random$id.sc_bio12$mean)


#pdf("fixed_arabidopsis.pdf", width = 9, height = 3)
p_fixed
#dev.off()

```


### Posterior distribution for the spatial effect
```{r, results='hide'}
raster_predict <- INLAcomp::raster_predict

spatial_mean <- raster_spatial_effect(spatial = model.typeVIII$summary.random[['i']][['mean']],
                                      boundary = raster_predict)


spatial_sd <- raster_spatial_effect(spatial = model.typeVIII$summary.random[['i']]$sd,
                                    boundary = raster_predict)
```


```{r}
par(mfrow = c(2,3))
plot(spatial_mean[[1]], main = "Mean")
plot(spatial_mean[[2]], main = "Mean")
plot(spatial_mean[[3]], main = "Mean")

plot(spatial_sd[[1]], main = "Sd")
plot(spatial_sd[[2]], main = "Sd")
plot(spatial_sd[[3]], main = "Sd")
```


### Posterior distribution of the hyperparameters
```{r}
### ------- 7.1.4. Posterior distributions of the hyperparameters --- ####
prec <- list(sigma2.1 = model.typeVIII$marginals.hyperpar$`Precision for the Gaussian observations`,
             sigma2.2 = model.typeVIII$marginals.hyperpar$`Precision for the Gaussian observations[2]`,
             sigma2.3 = model.typeVIII$marginals.hyperpar$`Precision for the Gaussian observations[3]`,
             gamma = model.typeVIII$marginals.hyper$`Precision for id.z`)

hyper <- lapply(1:length(prec),
                function(x){
                  inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%
                    data.frame(.)
                })
names(hyper) <- names(prec)
hyper <- c(hyper, 
           sigma.sp = list(inla.smarginal(model.typeVIII$marginals.hyperpar[["Stdev for i"]])),
           phi = list(inla.smarginal(model.typeVIII$marginals.hyperpar[["Range for i"]])))
hyper.df <- lapply(1:length(hyper),
                   function(x){
                     cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])
                   })  %>% 
  do.call(rbind.data.frame, .)

hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3",
                                     "gamma", "phi", "sigma.sp"))
hyper.df$name1 <- ordered(hyper.df$name1,
                          levels = c("sigma2.1", "sigma2.2", "sigma2.3", "gamma", "phi", "sigma.sp"),
                          labels = c("sigma[1]^2", "sigma[2]^2", "sigma[3]^2", "gamma", "phi", "sigma[w]"))

p.hyper <- ggplot(hyper.df) +
  geom_line(aes(x = x, y = y)) +
  facet_wrap(~ name1, scales = "free",
             labeller = label_parsed) +
  theme_bw() +
  xlab(expression(theta)) +
  ylab(expression(p(theta*'|'*y)))

#pdf("hyperpars.pdf", width = 7, height = 4)
print(p.hyper)
#dev.off()
```


# Comparing using DIC, WAIC and LCPO
In this tutorial, for the moment, we compute the DIC, WAIC and LCPO for all the models.

DIC and WAIC: We obtain the joint posterior distribution of the model using the `inla.posterior.sample` function. We use the functions `dic.mult` and `waic.mult` for computing the new DIC and WAIC.

CPO: We define friends in our dataset. We use the function `inla.group.cv` with the argument `num.level.sets = -1` for computing the CPO.


```{r}
model_list <- list(model.typeI,
               model.typeII,
               model.typeIII,
               model.typeIV,
               model.typeV,
               model.typeVI,
               model.typeVII,
               model.typeVIII)

names(model_list) <- paste0("type", c("I", "II", "III", "IV", "V", "VI", "VII", "VIII"))

## Computing measures of this model
measures <- lapply(model_list, function(mod1){
  xx <- inla.posterior.sample(1000, mod1, seed = inla.seed)
  inf <- mclapply(xx, INLAcomp::extract_lp_sigma)
  
  #DIC
  dic.mod1 <- INLAcomp::dic.mult(inf, y = data[, c(paste0("alr.gc", 1:(k-1)))])
  
  #WAIc
  waic.mod1 <- INLAcomp::waic.mult(inf, y = data[, c(paste0("alr.gc", 1:(k-1)))])
  
  #lIST FOR cpo
  friends_list <- 1:903 %>%
  lapply(., function(x){
    c(seq(x, 903, by = 301)[-1],
      rev(seq(x, 1, by = -301))) -> res
    res[order(res)]
  })
  
  a4 <- INLA::inla.group.cv(result = mod1,
                          num.level.sets = -1,
                          strategy = "posterior",
                          friends = friends_list)

  LCPO <- a4$cv %>% log(.) %>% mean(.) %>% -.
  
data.frame(DIC = dic.mod1, WAIC = waic.mod1, LCPO = LCPO)
  
})

measures <-  as.data.frame(do.call(rbind, measures))

measures %>%
  dplyr::select(DIC.dic, WAIC.waic, LCPO) %>%
  round(., 3) %>%
  xtable::xtable(., digits = 3)
```




<!-- # Predicting with the best model based on WAIC (Type VIII) -->

<!-- ## Preparing dataset for predictions -->
<!-- ```{r} -->

<!-- sim <- 1000 -->
<!-- locs_pred <- (coordinates(INLAcomp::raster_predict))[!is.na(values(INLAcomp::raster_predict)),] -->
<!-- n.pred <- dim(locs_pred)[1] -->



<!-- cat("\n ----------------------------------------------- \n") -->
<!-- cat("Creating the data.frame for predictions \n") -->

<!-- data_pred <- data.frame(intercept = 1, -->
<!--                         sc_bio1 = rep(raster::extract(sc_bio1, locs_pred), k-1), -->
<!--                         sc_bio12 = rep(raster::extract(sc_bio12, locs_pred), k-1)) -->
<!-- data_pred$sc_bio12 %>% summary(.) -->

<!-- id.z.pred  <- rep((n + 1):(n + n.pred), k-1) #random effect z to model the correlation -->

<!-- # Category -->
<!-- id.cat.pred <- rep(1:(k-1), rep(n.pred, k-1)) -->



<!-- #Defining the projection matrix -->
<!-- A.pred <- inla.spde.make.A(mesh, -->
<!--                            loc = do.call("rbind", -->
<!--                                          replicate(k-1, locs_pred, -->
<!--                                                    simplify = FALSE)), -->
<!--                            repl = rep(1:(k-1), rep(n.pred, k-1))) -->


<!-- # Category -->
<!-- id.cat_pred <- rep(1:(k-1), rep(n.pred, k-1)) -->

<!-- #Index for covariates -->
<!-- variables_pred <- c("intercept", data_pred %>% -->
<!--                       dplyr::select(starts_with("sc_")) %>% -->
<!--                       colnames(.)) -->

<!-- id.names_pred <- paste0("id.", variables_pred) -->
<!-- id.variables_pred <- rep(id.cat_pred, length(variables_pred)) %>% -->
<!--   matrix(., ncol = length(variables_pred), byrow = FALSE) -->
<!-- colnames(id.variables_pred) <- id.names_pred -->


<!-- #Index for iset without replicating -->
<!-- A.pred2 <- A.pred -->
<!-- ``` -->

<!-- ## Preparing `inla.stack` for predictions -->
<!-- ```{r} -->
<!-- cat("\n ----------------------------------------------- \n") -->
<!-- cat("Creating inla.stack \n") -->
<!-- stk.pred <- inla.stack(data    = list(resp = matrix(NA, ncol = k-1, -->
<!--                                                     nrow = n.pred*(k-1))), -->
<!--                        A       = list(A.pred, 1, A.pred2), -->
<!--                        effects = list(c(iset), -->
<!--                                       cbind(data_pred, -->
<!--                                             id.z = id.z.pred, -->
<!--                                             id.variables_pred), -->
<!--                                       data.frame(iset2)), -->
<!--                        tag     = 'pred') -->


<!-- ### --- Total stack -->
<!-- stk <- inla.stack(stk.est, stk.pred) -->
<!-- ``` -->



<!-- ## Prediction -->
<!-- ```{r, eval=TRUE} -->
<!-- cat("\n ----------------------------------------------- \n") -->
<!-- cat("Predicting \n") -->
<!-- mod.pred <- inla(formula.typeVIII, -->
<!--                  family         = rep("gaussian", k - 1), -->
<!--                  data              = inla.stack.data(stk), -->
<!--                  control.compute   = list(config = TRUE, cpo = TRUE, dic = TRUE, waic = TRUE), -->
<!--                  control.predictor = list(A = inla.stack.A(stk), compute = TRUE, link = 1), -->
<!--                  control.mode      = list(theta = model.typeVIII$mode$theta, restart = TRUE), -->
<!--                  control.family = list_prior, -->
<!--                  #control.fixed     = list(mean=0, prec=10^(-4), mean.intercept=0, prec.intercept=10^(-4)), -->
<!--                  # control.results   = list(return.marginals.random = FALSE, -->
<!--                  #                          return.marginals.predictor  = FALSE), #avoiding marginals -->
<!--                  num.threads       = 2, -->
<!--                  verbose           = FALSE) -->

<!-- mod.pred$summary.random$id.z -->


<!-- ### ----- 8.6. Extracting the predictions using inla.posterior.sample and come them back to the simplex --- #### -->
<!-- #We have to remove the variances of the error -->
<!-- pred.values.mean <- mod.pred$summary.fitted.values$mean[inla.stack.index(stk, 'pred')$data] %>% matrix(., ncol = k-1, byrow = FALSE) -->

<!-- cat("-----------------------------------------------") -->
<!-- cat("Posterior sample \n") -->
<!-- post_sim_pred <- inla.posterior.sample(n = sim, result = mod.pred, seed = inla.seed) -->
<!-- post_sim_predictor <- inla.posterior.sample.eval(fun = function(...){ -->
<!--   APredictor}, post_sim_pred, return.matrix = TRUE) -->
<!-- post_sim_idz <- inla.posterior.sample.eval(fun = function(...){ -->
<!--   id.z}, post_sim_pred, return.matrix = TRUE) -->


<!-- ind.pred <- inla.stack.index(stk, 'pred')$data -->
<!-- ind.idz <- inla.stack.index(stk, 'est')$data #This is the shared random effect -->
<!-- ind.idz <- ind.idz[1:(length(ind.idz)/(k-1))] -->

<!-- post_sim_predictor[ind.pred, ] <- post_sim_predictor[ind.pred, ]- -->
<!--   kronecker(rep(1, k-1), post_sim_idz[-ind.idz,]) -->


<!-- cat("\n ----------------------------------------------- \n") -->
<!-- cat("Start plotting \n") -->
<!-- ### ------- 8.6.1. Prediction in the alr-scale --- #### -->
<!-- apply(post_sim_predictor[ind.pred,], 2, function(x){ -->
<!--   alr_pred <- matrix(x, ncol = k-1) -->
<!--   alr_pred -->
<!--   as.numeric(t(alr_pred)) #Byrows -->
<!-- }) -> post_sim_pred_alr -->


<!-- #Computing mean and sd -->
<!-- #pred_simplex_summary <- t(apply(post_sim_pred_simplex, 1, function(x){c(sd(x), quantile(x, probs = c(0.025, 0.5, 0.975)))})) -->
<!-- pred_alr_summary <- t(apply(post_sim_pred_alr, 1, function(x){c(sd(x), mean(x))})) -->
<!-- colnames(pred_alr_summary) <- c("sd", "mean") -->
<!-- pred_alr_summary <- data.frame(pred_alr_summary, -->
<!--                                result1 = rep(names_alr, n.pred)) -->


<!-- #Plotting in a raster -->
<!-- raster_predictions_alr <- raster_predict -->

<!-- ### Mean -->
<!-- total_list_mean_alr <- lapply(names_alr, function(x){ -->
<!--   raster_predictions_alr[!is.na(raster_predict)] <- pred_alr_summary %>% -->
<!--     filter(., result1 == x) %>% -->
<!--     dplyr::select(mean) %>% pull(.) -->
<!--   raster_predictions_alr}) -->

<!-- pred_mean_alr <- stack(total_list_mean_alr) -->
<!-- names(pred_mean_alr) <- names_alr -->
<!-- par(mar = c(0,0,0,0)) -->
<!-- par(mfrow = c(2,1)) -->

<!-- ### Standard deviation -->
<!-- total_list_sd_alr <- lapply(names_alr, function(x){ -->
<!--   raster_predictions_alr[!is.na(raster_predict)] <- pred_alr_summary %>% -->
<!--     filter(., result1 == x) %>% -->
<!--     dplyr::select(sd) %>% pull(.) -->
<!--   raster_predictions_alr}) -->

<!-- pred_sd_alr <- stack(total_list_sd_alr) -->
<!-- names(pred_sd_alr) <- names_alr -->
<!-- par(mar = c(0,0,0,0)) -->
<!-- par(mfrow = c(2,1)) -->
<!-- #plot(pred_sd_alr) -->
<!-- ``` -->

<!-- ## Plotting predictions -->
<!-- ```{r, eval = TRUE} -->

<!-- ### --------- 8.6.1.1. Plotting predictions --- #### -->
<!-- pred_plot_mean_alr <- lapply(names_alr, -->
<!--                              plot_raster, rast = pred_mean_alr, -->
<!--                              ymin = -3.3, ymax = 3.75) -->

<!-- pred_plot_sd_alr <- lapply(names_alr, -->
<!--                            plot_raster, rast = pred_sd_alr, -->
<!--                            col1 = "F", ymin = 0.0, ymax = 1.25) -->

<!-- pred_plot_sd_alr[[3]] <- plot_raster(rast = pred_sd_alr, -->
<!--                                      col1 = "F", ymin = 0, ymax = 1.25, -->
<!--                                      sc = TRUE, cat = "alr.gc3") -->






<!-- mylegend_alr <- g_legend(pred_plot_mean_alr[[1]]) -->
<!-- mylegend2_alr <- g_legend(pred_plot_sd_alr[[1]]) -->


<!-- #pdf(paste0("arabidop_prediction_alr","_", "bio1_bio12", ".pdf"), width = 10, height = 7) -->
<!-- a1 <- grid.arrange(arrangeGrob(pred_plot_mean_alr[[1]] + theme(legend.position = "none"), -->
<!--                          pred_plot_mean_alr[[2]] + theme(legend.position = "none"), -->
<!--                          pred_plot_mean_alr[[3]] + theme(legend.position = "none"), -->
<!--                          nrow = 1), -->
<!--              mylegend_alr, -->
<!--              arrangeGrob(pred_plot_sd_alr[[1]] + theme(legend.position = "none"), -->
<!--                          pred_plot_sd_alr[[2]] + theme(legend.position = "none"), -->
<!--                          pred_plot_sd_alr[[3]] + theme(legend.position = "none"), -->
<!--                          nrow = 1), -->
<!--              mylegend2_alr, -->
<!--              nrow = 4, ncol = 1, heights = c(4, 1, 4, 1)) -->
<!-- print(a1) -->
<!-- #dev.off() -->

<!-- ``` -->

<!-- ```{r image-ref-for-in-text, echo = FALSE, message=FALSE, fig.align='center', fig.cap='Some cool caption', out.width='0.75\\linewidth', fig.pos='H'} -->
<!-- #knitr::include_graphics("arabidop_prediction_alr_bio1_bio12.png") -->
<!-- ``` -->
<!-- ## Predictions in the simplex -->
<!-- ```{r, eval = TRUE} -->
<!-- ### ------- 8.6.2. Prediction in the simplex --- ##### -->
<!-- apply(post_sim_predictor[ind.pred,], 2, function(x){ -->
<!--   alr_pred <- matrix(x, ncol = k-1) -->
<!--   pred_simplex <- compositions::alrInv(alr_pred) -->
<!--   as.numeric(t(pred_simplex)) #Byrows -->
<!-- }) -> post_sim_pred_simplex -->

<!-- dim(post_sim_pred_simplex) -->

<!-- #Computing credible intervals -->
<!-- #pred_simplex_summary <- t(apply(post_sim_pred_simplex, 1, function(x){c(sd(x), quantile(x, probs = c(0.025, 0.5, 0.975)))})) -->
<!-- pred_simplex_summary <- t(apply(post_sim_pred_simplex, 1, function(x){c(sd(x), mean(x))})) -->


<!-- colnames(pred_simplex_summary) <- c("sd", "mean") -->
<!-- pred_simplex_summary <- data.frame(pred_simplex_summary, -->
<!--                                    result1 = rep(result_order, n.pred)) -->

<!-- raster_predictions <- raster_predict -->

<!-- ### Median -->
<!-- total_list_mean <- lapply(result_order, function(x){ -->
<!--   raster_predictions[!is.na(raster_predict)] <- pred_simplex_summary %>% -->
<!--     filter(., result1 == x) %>% -->
<!--     dplyr::select(mean) %>% pull(.) -->
<!--   raster_predictions}) -->

<!-- pred_mean <- stack(total_list_mean) -->
<!-- names(pred_mean) <- result_order -->
<!-- par(mar = c(0,0,0,0)) -->
<!-- par(mfrow = c(2,1)) -->
<!-- #plot(pred_median) -->

<!-- ### Standard deviation -->
<!-- total_list_sd <- lapply(result_order, function(x){ -->
<!--   raster_predictions[!is.na(raster_predict)] <- pred_simplex_summary %>% -->
<!--     filter(., result1 == x) %>% -->
<!--     dplyr::select(sd) %>% pull(.) -->
<!--   raster_predictions}) -->

<!-- pred_sd <- stack(total_list_sd) -->
<!-- names(pred_sd) <- result_order -->
<!-- par(mar = c(0,0,0,0)) -->
<!-- par(mfrow = c(2,1)) -->
<!-- #plot(pred_sd) -->

<!-- ### --------- 8.6.2.1. Plotting predictions --- #### -->
<!-- pred_plot_mean <- lapply(c(paste0("gc", 1:k)), -->
<!--                          plot_raster, rast = pred_mean) -->

<!-- pred_plot_sd <- lapply(c(paste0("gc", 1:k)), -->
<!--                        plot_raster, rast = pred_sd, -->
<!--                        col1 = "F", ymax = 0.25) -->
<!-- pred_plot_sd[[4]] <- plot_raster(rast = pred_sd, col1 = "F", ymax = 0.4, sc = TRUE, cat = "gc4") -->


<!-- mylegend <- g_legend(pred_plot_mean[[1]]) -->
<!-- mylegend2 <- g_legend(pred_plot_sd[[1]]) -->


<!-- # pdf(paste0("arabidop_prediction","_", "bio1_bio12", ".pdf"), -->
<!-- #        width = 12, height = 7) -->
<!-- b <- grid.arrange(arrangeGrob(pred_plot_mean[[1]] + theme(legend.position = "none"), -->
<!--                          pred_plot_mean[[2]] + theme(legend.position = "none"), -->
<!--                          pred_plot_mean[[3]] + theme(legend.position = "none"), -->
<!--                          pred_plot_mean[[4]] + theme(legend.position = "none"), -->
<!--                          nrow = 1), -->
<!--              mylegend, -->
<!--              arrangeGrob(pred_plot_sd[[1]] + theme(legend.position = "none"), -->
<!--                          pred_plot_sd[[2]] + theme(legend.position = "none"), -->
<!--                          pred_plot_sd[[3]] + theme(legend.position = "none"), -->
<!--                          pred_plot_sd[[4]] + theme(legend.position = "none"), -->
<!--                          nrow = 1), -->
<!--              mylegend2, -->
<!--              nrow = 4, ncol = 1, heights = c(4, 1, 4, 1)) -->
<!-- print(b) -->
<!-- #dev.off() -->
<!-- #getwd() -->
<!-- ``` -->
