[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 INLAcomp authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/Dirichlet-CoDa.html","id":"an-introduction-to-the-logistic-normal-dirichlet-regression","dir":"Articles","previous_headings":"","what":"An introduction to the Logistic Normal Dirichlet Regression","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"defined Martƒ±ÃÅnez-Minaya Rue (2024), ùê≤‚ààùïäD\\boldsymbol{y} \\\\mathbb{S}^D follows logistic-normal distribution Dirichlet covariance ‚Ñíùí©ùíü(ùõç,ùö∫)\\mathcal{LND}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}) alr(ùê≤)‚àºùí©(ùõç,ùö∫)alr(\\boldsymbol{y}) \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}), : Œ£dd=œÉd2+Œ≥,d=1,‚Ä¶,D‚àí1Œ£dk=Œ≥,d‚â†k\\begin{equation} \\begin{array}{rcl} \\Sigma_{dd} & = & \\sigma_d^2 + \\gamma \\,, \\ d = 1, \\ldots, D-1 \\\\ \\Sigma_{dk} & = & \\gamma\\,, d \\neq k \\, \\nonumber \\end{array} \\end{equation} œÉd2+Œ≥\\sigma_d^2 + \\gamma represents variance log-ratio Œ≥\\gamma covariance log-ratios. now refer ùí©ùíü(ùõç,ùö∫)\\mathcal{ND}(\\boldsymbol{\\mu},\\boldsymbol{\\Sigma}) multivariate normal Dirichlet covariance structure. Let ùê≤\\boldsymbol{y} multivariate random variable ùê≤‚àº‚Ñíùí©ùíü(ùõç,ùö∫)\\boldsymbol{y} \\sim \\mathcal{LND}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}), definition equivalent alr(ùê≤)‚àºùí©ùíü(ùõç,ùö∫)alr(\\boldsymbol{y} ) \\sim \\mathcal{ND}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}). easy interpretability terms log-ratios reference category, focus modelling alr(ùê≤)alr(\\boldsymbol{y}) ùí©ùíü(ùõç,ùö∫)\\mathcal{ND}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}).","code":""},{"path":"/articles/Dirichlet-CoDa.html","id":"simulated-example-i-type-ii","dir":"Articles","previous_headings":"","what":"Simulated example I (Type II)","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"model going operate example presents following structure: alr(ùêò)‚àºùí©ùíü((ùõç(1),‚Ä¶,ùõç(D)),ùö∫)ùõç(d)=ùêóùõÉ(d),\\begin{eqnarray}     alr(\\boldsymbol{Y} ) & \\sim & \\mathcal{ND}((\\boldsymbol{\\mu}^{(1)}, \\ldots, \\boldsymbol{\\mu}^{(D)}), \\boldsymbol{\\Sigma}) \\\\     \\boldsymbol{\\mu}^{(d)} & = & \\boldsymbol{X} \\boldsymbol{\\beta}^{(d)}  \\label{eq::model_arabidopsis}\\,,  \\end{eqnarray} Note second structure presented Martƒ±ÃÅnez-Minaya Rue (2024), working assumption covariates different effect linear predictor. particular, consider D=3D = 3, reference category third one. , dealing two alralr-coordinates. Also, just generate covariate xx scaled mean 0 standard deviation 1. alr(ùêò)‚àºùí©ùíü((ùõç(1),ùõç(2)),ùö∫),ùõç(1)=Œ≤0(1)+Œ≤1(1)ùê±,ùõç(2)=Œ≤1(2)+Œ≤1(2)ùê±.\\begin{eqnarray}     alr(\\boldsymbol{Y} ) & \\sim & \\mathcal{ND}((\\boldsymbol{\\mu}^{(1)},  \\boldsymbol{\\mu}^{(2)}), \\boldsymbol{\\Sigma}) \\,, \\\\     \\boldsymbol{\\mu}^{(1)} & = & \\beta_0^{(1)} + \\beta_1^{(1)} \\boldsymbol{x} \\nonumber \\,,\\\\     \\boldsymbol{\\mu}^{(2)} & = & \\beta_1^{(2)} + \\beta_1^{(2)} \\boldsymbol{x} \\,. \\label{eq::model_sim} \\end{eqnarray}","code":""},{"path":"/articles/Dirichlet-CoDa.html","id":"data-simulation","dir":"Articles","previous_headings":"Simulated example I (Type II)","what":"Data simulation","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"set.seed(201803) inla.seed = sample.int(n=1E6, size=1) options(width=70, digits=3)"},{"path":"/articles/Dirichlet-CoDa.html","id":"defining-hyperparameters-and-dimensionality-of-the-response","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data simulation","what":"Defining hyperparameters and dimensionality of the response","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"start defining hyperparameters likelihood: œÉ12=0.5\\sigma_1^2 = 0.5, œÉ22=0.4\\sigma_2^2 = 0.4 Œ≥=0.1\\gamma = 0.1, computing correlation matrix alralr-coordinates.","code":"### --- 1. Simulation --- #### # Parameters for the simulation D <- 3 N <- 1000 sigma2 <- c(0.5, 0.4) cov_param <- 0.1 sigma_diag <- sqrt(sigma2 + cov_param) hypers_lik <- data.frame(hypers = c(sigma2, cov_param),                          name1 = c(\"sigma2.1\", \"sigma2.2\", \"gamma\")) # We create the correlation parameters based on the previous idea # We are going to have ((D-1)^2 - (D-1))/2 rhos rho <- diag(1/sigma_diag) %*% matrix(cov_param, D-1, D-1) %*% diag(1/sigma_diag) diag(rho) <- 1 rho ##       [,1]  [,2] ## [1,] 1.000 0.183 ## [2,] 0.183 1.000"},{"path":"/articles/Dirichlet-CoDa.html","id":"simulating-a-covariate","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data simulation","what":"Simulating a covariate","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"define covariate ùê±\\boldsymbol{x} also, corresponding betas, constructing corresponding linear predictor.","code":"x = runif(N)-0.5 # - mean 0 to not affect intercept betas = matrix(c(-1, 3, -1, 5), nrow = D-1, byrow = TRUE) X <- data.frame(1, x) %>% as.matrix(.) lin.pred <- X %*% t(betas)"},{"path":"/articles/Dirichlet-CoDa.html","id":"alr-coordinates","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data simulation","what":"alr-coordinates","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"construct alralr-coordinates","code":"### ------- 1.2.3. Constructing the likelihood --- #### Sigma <- matrix(sigma_diag, ncol = 1) %*% matrix(sigma_diag, nrow = 1) Sigma <- Sigma*rho  lin.pred %>%   apply(., 1, function(z)     MASS::mvrnorm( n  = 1,              mu = z,              Sigma = Sigma)) %>%   t(.)-> alry"},{"path":"/articles/Dirichlet-CoDa.html","id":"data-in-the-simplex","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data simulation","what":"Data in the simplex","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"move back Simplex using alralr-inverse, particular, use function alrInv form R-package compositions.","code":"y.simplex <- compositions::alrInv(alry)   y.simplex <- as.numeric(t(y.simplex)) %>% matrix(., ncol = D, byrow = TRUE)   colnames(y.simplex) <- paste0(\"y\", 1:D)     data <- data.frame(alry, y.simplex, x) colnames(data)[1:(D-1)] <- c(paste0(\"alry.\", 1:(D-1))) data %>% head(.) ##   alry.1 alry.2    y1     y2    y3       x ## 1 -1.580  -1.46 0.143 0.1620 0.695  0.0265 ## 2 -1.345  -3.18 0.200 0.0318 0.768 -0.3708 ## 3 -1.735  -1.52 0.126 0.1567 0.717  0.0819 ## 4 -1.012  -2.01 0.243 0.0898 0.667 -0.0377 ## 5 -0.584  -1.53 0.314 0.1224 0.563  0.0775 ## 6 -0.041   2.10 0.095 0.8060 0.099  0.3962"},{"path":"/articles/Dirichlet-CoDa.html","id":"plotting-the-simulated-data","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data simulation","what":"Plotting the simulated data","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"Simulated data using alr-coordinates terms x","code":"### Alr coordinates data %>%    tidyr::pivot_longer(., cols = ,starts_with(\"alr\"),                        names_to = \"y.names\", values_to = \"y.resp\") %>%   ggplot(data = .) +   geom_point(aes(x = x, y = y.resp, fill = x), shape = 21, size = 2) +   ylab(\"alr\") +   facet_wrap(~y.names) +   theme_bw() +   theme(legend.position = \"bottom\") -> p_alr  #pdf(\"simulated_data.pdf\", width = 8, height = 6) p_alr #dev.off()"},{"path":[]},{"path":"/articles/Dirichlet-CoDa.html","id":"index-for-individual","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data preparation for fitting","what":"Index for individual","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"data$id.z <- 1:dim(data)[1]"},{"path":"/articles/Dirichlet-CoDa.html","id":"extending-the-dataset","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data preparation for fitting","what":"Extending the dataset","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"extent data alralr-coordinates introducing inla.stack","code":"data_ext <- data %>%   tidyr::pivot_longer(., cols = all_of(paste0(\"alry.\", 1:(D-1))),                       names_to  = \"y.names\",                       values_to = \"y.resp\") %>%   .[order(ordered(.$y.names)),] data_ext$y.names <- ordered(data_ext$y.names) head(data_ext) ## # A tibble: 6 √ó 7 ##       y1     y2     y3       x  id.z y.names  y.resp ##    <dbl>  <dbl>  <dbl>   <dbl> <int> <ord>     <dbl> ## 1 0.143  0.162  0.695   0.0265     1 alry.1  -1.58   ## 2 0.200  0.0318 0.768  -0.371      2 alry.1  -1.35   ## 3 0.126  0.157  0.717   0.0819     3 alry.1  -1.74   ## 4 0.243  0.0898 0.667  -0.0377     4 alry.1  -1.01   ## 5 0.314  0.122  0.563   0.0775     5 alry.1  -0.584  ## 6 0.0950 0.806  0.0990  0.396      6 alry.1  -0.0410"},{"path":"/articles/Dirichlet-CoDa.html","id":"response-in-r-inla","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data preparation for fitting","what":"Response in R-INLA","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"create matrix dimension (N√ó(D‚àí1))√ó(D‚àí1)(N \\times (D-1)) \\times (D-1) including multivariate response R-INLA","code":"names_y <- paste0(\"alry.\", 1:(D-1)) 1:length(names_y) %>%   lapply(., function(i){     data_ext %>%       dplyr::filter(y.names == names_y[i]) -> data_comp_i     #Response     y_alr <- matrix(ncol = names_y %>% length(.), nrow = dim(data_comp_i)[1])     y_alr[, i] <- data_comp_i$y.resp   }) -> y.resp  1:length(names_y) %>%   lapply(., function(i){     y_aux <- data_ext %>%       dplyr::select(y.resp, y.names) %>%       dplyr::filter(y.names == names_y[i]) %>%       dplyr::select(y.resp) %>%       as.matrix(.)     aux_vec <- rep(NA, (D-1))     aux_vec[i] <- 1     kronecker(aux_vec, y_aux)   }) -> y_list  y_tot <- do.call(cbind, y_list) y_tot %>% head(.) ##        [,1] [,2] ## [1,] -1.580   NA ## [2,] -1.345   NA ## [3,] -1.735   NA ## [4,] -1.012   NA ## [5,] -0.584   NA ## [6,] -0.041   NA"},{"path":"/articles/Dirichlet-CoDa.html","id":"covariates-in-r-inla","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data preparation for fitting","what":"Covariates in R-INLA","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"Covariates going included model random effects big variance. , need values covariates, also, index indicating alr-coordinate belongs.","code":"variables <- c(\"intercept\", data %>%                  dplyr::select(starts_with(\"x\")) %>%                  colnames(.)) id.names <- paste0(\"id.\", variables) id.variables <- rep(data_ext$y.names %>% as.factor(.) %>% as.numeric(.),                      length(variables)) %>%   matrix(., ncol = length(variables), byrow = FALSE) colnames(id.variables) <- id.names  variables ## [1] \"intercept\" \"x\" id.variables %>% head(.) ##      id.intercept id.x ## [1,]            1    1 ## [2,]            1    1 ## [3,]            1    1 ## [4,]            1    1 ## [5,]            1    1 ## [6,]            1    1"},{"path":"/articles/Dirichlet-CoDa.html","id":"inla-stack","dir":"Articles","previous_headings":"Simulated example I (Type II) > Data preparation for fitting","what":"inla.stack","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"create inla.stack estimation","code":"stk.est <- inla.stack(data    = list(resp = y_tot),                       A       = list(1),                       effects = list(cbind(data_ext %>%                                              dplyr::select(starts_with(\"x\")),                                            data_ext %>%                                              dplyr::select(starts_with(\"id.z\")),                                            id.variables,                                            intercept = 1)),                       tag     = 'est')"},{"path":"/articles/Dirichlet-CoDa.html","id":"fitting-the-model","dir":"Articles","previous_headings":"Simulated example I (Type II)","what":"Fitting the model","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"section, fit model (Type II manuscript), obtain marginal posterior distribution parameters hyperparameters","code":""},{"path":"/articles/Dirichlet-CoDa.html","id":"fit-in-r-inla","dir":"Articles","previous_headings":"Simulated example I (Type II) > Fitting the model","what":"Fit in R-INLA","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"# Have different parameters for fixed effects, and do not include spatial random effects. list_prior <- rep(list(list(prior = \"pc.prec\", param = c(1, 0.01))), D-1)  ### Fitting the model formula.typeII <- resp ~ -1 +   f(id.intercept, intercept,     model   = \"iid\",     initial = log(1/1000),     fixed   = TRUE) +   f(id.x, x,     model   = \"iid\",     initial = log(1/1000),     fixed   = TRUE) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))), constr = TRUE) model.typeII <- inla(formula.typeII,                      family         = rep(\"gaussian\", D-1),                      data           = inla.stack.data(stk.est),                      control.compute = list(config = TRUE),                      control.predictor = list(A = inla.stack.A(stk.est),                                               compute = TRUE),                      control.family = list_prior,                      inla.mode = \"experimental\" ,                      verbose = FALSE)"},{"path":"/articles/Dirichlet-CoDa.html","id":"marginal-posterior-distribution-of-the-fixed-effects","dir":"Articles","previous_headings":"Simulated example I (Type II) > Fitting the model","what":"Marginal posterior distribution of the fixed effects","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"### Posterior distribution of the fixed effects data_fixed <- rbind(data.frame(inla.smarginal(model.typeII$marginals.random$id.x$index.1),                                alr = \"alr(y1/y3)\",                                var = \"x\",                                param = \"beta1\",                                real  = betas[1,2]),                     data.frame(inla.smarginal(model.typeII$marginals.random$id.x$index.2),                                alr = \"alr(y2/y3)\",                                var = \"x\",                                param = \"beta1\",                                real  = betas[2,2]),                     data.frame(inla.smarginal(model.typeII$marginals.random$id.intercept$index.1),                                alr = \"alr(y1/y3)\",                                var = \"intercept\",                                param = \"beta0\",                                real = betas[1,1]),                     data.frame(inla.smarginal(model.typeII$marginals.random$id.intercept$index.2),                                alr = \"alr(y2/y3)\",                                var = \"intercept\",                                param = \"beta0\",                                real = betas[2,1]))  p_fixed <- ggplot() +   geom_line(data = data_fixed, aes(x = x, y = y), size = 0.9) +   #ggtitle(\"Effect of the covariate bio12\") +   theme_bw() +   geom_vline(data = data_fixed, aes(xintercept = real), col = \"red4\") +  # scale_color_manual(values=c(\"#E75F00\", \"#56B4E9\"))+   theme(legend.position = \"bottom\") +   facet_wrap(~param + alr, ncol = D-1, scales = \"free\") +   xlab(expression(beta^(d))) +   ylab(expression(p(beta^(d) *'|'* theta))) +   theme(legend.title = element_blank())  #pdf(\"posterior_fixed.pdf\", width = 6, height = 5) p_fixed #dev.off()"},{"path":"/articles/Dirichlet-CoDa.html","id":"marginal-posterior-distribution-of-the-hyperparameters","dir":"Articles","previous_headings":"Simulated example I (Type II) > Fitting the model","what":"Marginal Posterior distribution of the hyperparameters","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"### Posterior distribution of the hyperparameters prec <- list(sigma2.1 = model.typeII$marginals.hyperpar$`Precision for the Gaussian observations`,              sigma2.2 = model.typeII$marginals.hyperpar$`Precision for the Gaussian observations[2]`,              gamma = model.typeII$marginals.hyper$`Precision for id.z`)  hyper <- lapply(1:length(prec),                 function(x){                   inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%                     data.frame(.)                 }) names(hyper) <- names(prec)  hyper.df <- lapply(1:length(hyper),                    function(x){                      cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])                    })  %>%   do.call(rbind.data.frame, .)  hyper.df$name1 <- ordered(hyper.df$name1,                           levels = c(\"sigma2.1\", \"sigma2.2\",                                      \"gamma\")) p.hyper <- ggplot(hyper.df) +   geom_line(aes(x = x, y = y)) +   geom_vline(data = hypers_lik, aes(xintercept = hypers), col = \"red4\") +   facet_wrap(~ name1, scales = \"free\") +   theme_bw() +   xlab(expression(theta)) +   ylab(expression(p(theta*'|'*y)))  #pdf(\"marginals_hyperpar.pdf\", width = 6, height = 3) print(p.hyper) #dev.off()"},{"path":"/articles/Dirichlet-CoDa.html","id":"predicting-for-a-new-observation","dir":"Articles","previous_headings":"Simulated example I (Type II)","what":"Predicting for a new observation","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"section, devoted explain make predictions. want predict, values covariate x=‚àí0.5,‚àí0.2,0.1,0.4x = -0.5, -0.2, 0.1, 0.4. particular, show compute posterior preditive distribution mean alralr-coordinates. Posteriorly, move back Simplex.","code":""},{"path":"/articles/Dirichlet-CoDa.html","id":"preparing-dataset-for-predictions","dir":"Articles","previous_headings":"Simulated example I (Type II) > Predicting for a new observation","what":"Preparing dataset for predictions","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"sim <- 1000 x.pred <- seq(-0.5, 0.5, 0.3) n.pred <- length(x.pred) cat(\"\\n ----------------------------------------------- \\n\") ##  ##  ----------------------------------------------- cat(\"Creating the data.frame for predictions \\n\") ## Creating the data.frame for predictions data_pred <- data.frame(intercept = 1,                         x = rep(x.pred, D-1)) id.z.pred  <- rep((N + 1):(N + n.pred), D - 1) #random effect z to model the correlation  # Category id.cat_pred <- rep(1:(D - 1), rep(n.pred, D - 1)) #Index for covariates variables_pred <- c(\"intercept\", data_pred %>%                        dplyr::select(starts_with(\"x\")) %>%                        colnames(.)) id.names_pred <- paste0(\"id.\", variables_pred) id.variables_pred <- rep(id.cat_pred, length(variables_pred)) %>%    matrix(., ncol = length(variables_pred), byrow = FALSE) colnames(id.variables_pred) <- id.names_pred"},{"path":"/articles/Dirichlet-CoDa.html","id":"preparing-inla-stack-for-predictions","dir":"Articles","previous_headings":"Simulated example I (Type II) > Predicting for a new observation","what":"Preparing inla.stack for predictions","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"stk.pred <- inla.stack(data    = list(resp = matrix(NA, ncol = D - 1,                                                      nrow = n.pred*(D - 1))),                        A       = list(1),                        effects = list(cbind(data_pred,                                             id.z = id.z.pred,                                             id.variables_pred)),                        tag     = 'pred') ### --- Total stack stk <- inla.stack(stk.est, stk.pred)"},{"path":"/articles/Dirichlet-CoDa.html","id":"prediction","dir":"Articles","previous_headings":"Simulated example I (Type II) > Predicting for a new observation","what":"Prediction","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"mod.pred <- inla(formula.typeII,                   family         = rep(\"gaussian\", D - 1),                  data              = inla.stack.data(stk),                   control.compute   = list(config = TRUE),                  control.predictor = list(A = inla.stack.A(stk), compute = TRUE, link = 1),                  control.mode      = list(theta = model.typeII$mode$theta, restart = TRUE),                   control.family = list_prior,                     num.threads       = 2,                  inla.mode = \"experimental\" ,                   verbose           = FALSE)"},{"path":"/articles/Dirichlet-CoDa.html","id":"extracting-predictions-using-inla-posterior-sample","dir":"Articles","previous_headings":"Simulated example I (Type II) > Predicting for a new observation","what":"Extracting predictions using inla.posterior.sample","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"pred.values.mean <- mod.pred$summary.fitted.values$mean[inla.stack.index(stk, 'pred')$data] %>%    matrix(., ncol = D - 1, byrow = FALSE)  post_sim_pred <- inla.posterior.sample(n = sim, result = mod.pred) post_sim_predictor <- inla.posterior.sample.eval(fun = function(...){   APredictor}, post_sim_pred, return.matrix = TRUE) post_sim_idz <- inla.posterior.sample.eval(fun = function(...){   id.z}, post_sim_pred, return.matrix = TRUE)  ind.pred <- inla.stack.index(stk, 'pred')$data ind.idz <- inla.stack.index(stk, 'est')$data #This is the shared random effect ind.idz <- ind.idz[1:(length(ind.idz)/(D - 1))]  post_sim_predictor[ind.pred, ] <- post_sim_predictor[ind.pred, ]-    kronecker(rep(1, D-1), post_sim_idz[-ind.idz,])  post_sim_pred_alr <- post_sim_predictor[ind.pred,]  #Computing mean and sd pred_alr_summary <- t(apply(post_sim_pred_alr, 1, function(x){c(mean(x), sd(x))})) pred_alr_summary <- data.frame(pred_alr_summary,                                 y.names = rep(names_y, rep(n.pred, D-1)),                                x.pred = rep(x.pred, D-1)) colnames(pred_alr_summary)[1:2] <- c(\"mean\", \"sd\")  pred_alr_summary ##             mean     sd y.names x.pred ## fun[2001] -2.543 0.0511  alry.1   -0.5 ## fun[2002] -1.620 0.0301  alry.1   -0.2 ## fun[2003] -0.698 0.0243  alry.1    0.1 ## fun[2004]  0.225 0.0408  alry.1    0.4 ## fun[2005] -3.466 0.0435  alry.2   -0.5 ## fun[2006] -1.994 0.0252  alry.2   -0.2 ## fun[2007] -0.522 0.0219  alry.2    0.1 ## fun[2008]  0.950 0.0378  alry.2    0.4"},{"path":"/articles/Dirichlet-CoDa.html","id":"predictions-in-the-simplex","dir":"Articles","previous_headings":"Simulated example I (Type II) > Predicting for a new observation","what":"Predictions in the simplex","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure","text":"","code":"###  Prediction in the simplex --- ##### apply(post_sim_predictor[ind.pred,], 2, function(x){   alr_pred <- matrix(x, ncol = D - 1)   pred_simplex <- compositions::alrInv(alr_pred)   as.numeric(t(pred_simplex)) #Byrows }) -> post_sim_pred_simplex  #Computing credible intervals pred_simplex_summary <- t(apply(post_sim_pred_simplex, 1, function(x){c(mean(x), sd(x))})) pred_simplex_summary <- data.frame(pred_simplex_summary,                                     y.names = rep(c(\"y1\", \"y2\", \"y3\"), n.pred),                                    x.pred  = rep(x.pred, rep(D, n.pred))) colnames(pred_simplex_summary)[1:2] <- c(\"mean\", \"sd\")  pred_simplex_summary ##      mean      sd y.names x.pred ## 1  0.0709 0.00336      y1   -0.5 ## 2  0.0282 0.00118      y2   -0.5 ## 3  0.9009 0.00357      y3   -0.5 ## 4  0.1484 0.00381      y1   -0.2 ## 5  0.1021 0.00233      y2   -0.2 ## 6  0.7496 0.00396      y3   -0.2 ## 7  0.2380 0.00467      y1    0.1 ## 8  0.2838 0.00476      y2    0.1 ## 9  0.4782 0.00406      y3    0.1 ## 10 0.2588 0.00899      y1    0.4 ## 11 0.5345 0.01050      y2    0.4 ## 12 0.2067 0.00488      y3    0.4"},{"path":[]},{"path":"/articles/simulations.html","id":"functions-for-plotting","dir":"Articles","previous_headings":"","what":"Functions for plotting","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"## -------------------------------------- #' Include a suffix to variable names #' #' Used with \\code{\\link[INLA]{inla.stack}} for building effect stacks. #' #' @param x a data.frame #' @param suffix character string to be appended to variable names #' @param makeNA logical. If \\code{TRUE}, returns the suffixed data.frame filled #'   with \\code{NA}. #' @export suffix <- function(x, suffix, makeNA = FALSE) {   z <- structure(x, names = paste(names(x), suffix, sep = '.'))   if(makeNA) z[] <- NA   z }  ### --- function to convert matrix to raster --- #### rotate <- function(x)(apply(x,2,rev))  matrix_to_raster <- function(m, proj.grid.mat = proj.grid.mat) {   raster(rotate(t(m)),          xmn = min(proj.grid.mat$lattice$loc[,1]),          xmx = max(proj.grid.mat$lattice$loc[,1]),          ymn = min(proj.grid.mat$lattice$loc[,2]),          ymx = max(proj.grid.mat$lattice$loc[,2])) }  # Legend g_legend <- function(a.gplot) {   tmp <- ggplot_gtable(ggplot_build(a.gplot))   leg <- which(sapply(tmp$grobs, function(x) x$name) == \"guide-box\")   legend <- tmp$grobs[[leg]]   return(legend) }   ### raster_spatial_effect <- function(spatial, boundary,                                   boundary1 = INLAcomp::polygon_IP,                                   rast = TRUE,                                   res = c(5000, 5000)) {    if(rast == TRUE){     res <- res(raster_predict)   }   proj <- inla.mesh.projector(mesh,                               xlim = bbox(boundary)[1,],                               ylim = bbox(boundary)[2,],                               dims = c(round((bbox(boundary)[1,\"max\"] - bbox(boundary)[1,\"min\"])/res[1],0),                                        round((bbox(boundary)[2,\"max\"]-bbox(boundary)[2,\"min\"])/res[2],0)))    if(length(spatial) == mesh$n)   {     field.proj = inla.mesh.project(proj, spatial[1:mesh$n])      field1 <- matrix_to_raster(field.proj, proj.grid.mat = proj)     #field1 <- crop(field1, boundary)     #field1 <- mask(field1, boundary)     #plot(field1)   }else{     res <- matrix(spatial, byrow = FALSE, ncol = k-1)     total <- apply(res, 2,                    function(x){                      res1 <- inla.mesh.project(proj, x)                      field1 <- matrix_to_raster(res1, proj.grid.mat = proj)                      #field1 <- crop(field1, boundary1)                      #field1 <- mask(field1, boundary1)                      #plot(field1)                      #field1                    })     field1 <- raster::stack(total)   }   field1 }   #Plotting rasters plot_raster <- function(rast, cat, names,                         sc = FALSE,                         col1 = \"B\",                         ymin = 0, ymax = 1,                         legkeywidth = 1,                         poly) {   sp_eus2 <- fortify(poly)   rast_gc1 <- as(rast[[cat]], \"SpatialPixelsDataFrame\")   rast_gc1 <- as.data.frame(rast_gc1)   colnames(rast_gc1) <- c(\"value\", \"lon\", \"lat\")    gc1_pred <- ggplot() +     geom_tile(data = rast_gc1, aes(x = lon, y = lat, fill = value)) +     # geom_polygon(data = poly, aes(x = long, y = lat, group = group),     #              fill = NA, color = \"gray20\", size = 0.25) +     coord_equal(ratio = 1) +     ggtitle(names) +     theme(line = element_blank(), # remove axis lines ..           axis.text = element_blank(),                       # .. tickmarks..           axis.title = element_blank(),           panel.background = element_blank(),           legend.position = \"bottom\",           legend.key.height = unit(0.5, \"cm\"),           legend.key.width = unit(legkeywidth, \"cm\"),           legend.title = element_blank(),           legend.text = element_text(size = 14),           plot.title = element_text(size = 14, hjust = 0.5, vjust = -3)) +     #scale_fill_viridis(option = col1, direction = -1, limits = c(ymin, ymax)) +     scale_fill_gradientn(colours = rev(RColorBrewer::brewer.pal(11, \"RdYlBu\")),                          limits = c(ymin, ymax))   if(sc == TRUE)   {      gc1_pred <- gc1_pred +       ggsn::scalebar(sp_eus2, location = \"bottomright\",                      dist = 200, transform = FALSE,                      st.size = 3, st.dist = 0.05, height=0.03,                      dist_unit = \"km\")     #ggsn::north(sp_eus2, location = \"topright\", scale = 0.2,     #            symbol = 4)     #ggsn::north2(sp_eus2, x = 0.65, y = 0.9, scale = 0.1, symbol = 1)     #    }   gc1_pred  }     colsc <- function(...) {   scale_fill_gradientn(     colours = rev(RColorBrewer::brewer.pal(11, \"RdYlBu\")),     limits = range(..., na.rm = TRUE)   ) }"},{"path":"/articles/simulations.html","id":"simulating-a-dataset-with-replicate-random-effects","dir":"Articles","previous_headings":"","what":"Simulating a dataset with replicate random effects","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Defining parameters seeds replicating.","code":"true_range <- 4 true_sigma <- 1 D <- 3 N <- 1000   set.seed(314) inla.seed = sample.int(n=1E6, size=1)"},{"path":"/articles/simulations.html","id":"constructing-a-2d-model-in-a-grid","dir":"Articles","previous_headings":"Simulating a dataset with replicate random effects","what":"Constructing a 2D model in a grid","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"now construct 2D model, generate sample random field, attempt recover field observations locations. First, build high resolution mesh true field, using low level INLA functions.","code":"bnd <- inlabru::spoly(data.frame(x = c(0, 10, 10, 0), y = c(0, 0, 10, 10))) mesh_fine <- inla.mesh.2d(boundary = bnd, max.edge = 0.2) ggplot() +   gg(mesh_fine) +   coord_equal() # Note: the priors here will not be used in estimation matern_fine <-   inla.spde2.pcmatern(mesh_fine,                       prior.sigma = c(1, 0.01),                       prior.range = c(1, 0.01)   )  true_Q <- inla.spde.precision(matern_fine, theta = log(c(true_range, true_sigma)))"},{"path":"/articles/simulations.html","id":"samples-from-the-fields","dir":"Articles","previous_headings":"Simulating a dataset with replicate random effects","what":"Samples from the fields","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Generating couple samples model:","code":"true_field <- inla.qsample(D-1, true_Q, seed = inla.seed) #> Warning in inla.qsample(D - 1, true_Q, seed = inla.seed): Since 'seed!=0', #> parallel model is disabled and serial model is selected truth <- expand.grid(   lon = seq(0, 10, length = 500),   lat = seq(0, 10, length = 500)) raster_predict <- rasterFromXYZ(truth) raster_predict[!is.na(raster_predict)] <- 0   truth <- fm_evaluate(   mesh_fine,   loc = as.matrix(truth),   field = true_field ) %>% cbind(truth, .) names(truth) <- c(\"lon\", \"lat\", paste0(\"field\", 1:(D-1)))  coordinates(truth) <- c(\"lon\", \"lat\") truth <- as(truth, \"SpatialPixelsDataFrame\")  plot_truth <- lapply(1:(D-1), function(dd){   csc1 <- colsc(truth[[dd]])   ggplot() +     gg(truth, mapping = aes_string(\"lon\", \"lat\", fill = paste0(\"field\", dd))) +     coord_equal() +     ggtitle(paste0(\"True field \", dd)) + csc1 }) #> Warning: `aes_string()` was deprecated in ggplot2 3.0.0. #> ‚Ñπ Please use tidy evaluation idioms with `aes()`. #> ‚Ñπ See also `vignette(\"ggplot2-in-packages\")` for more information. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated.  truth_r <- stack(truth) multiplot(plotlist = plot_truth,  cols = (D-1))"},{"path":"/articles/simulations.html","id":"observations-from-points--adding-covariates","dir":"Articles","previous_headings":"Simulating a dataset with replicate random effects","what":"Observations from points. Adding covariates","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Extract observations random locations:","code":"set.seed(51) D <- k <- D #betas <- matrix(c(2.2, -2.4), nrow = D-1, byrow = FALSE) (betas <- matrix(c(2 + runif(1, -0.5, 0.5),                     -2 + runif(1, -0.5, 0.5)), nrow = D-1, byrow = FALSE)) #>           [,1] #> [1,]  2.275975 #> [2,] -2.299530   #Covariance matrix of the response sigma2 <- runif( D-1, 0.2, 0.6) %>% round(., 2) cov_param <- 0.1  data <- data.frame(lon = runif(N, 0, 10),                    lat = runif(N, 0, 10))  sigma_diag <- sqrt(sigma2 + cov_param)  hypers_lik <- data.frame(hypers = c(sigma2, cov_param),                          name1 = c(\"sigma2.1\", \"sigma2.2\",                                    \"gamma\"))   # We create the correlation parameters based on the previous idea # We are going to have ((D-1)^2 - (D-1))/2 rhos rho <- diag(1/sigma_diag) %*% matrix(cov_param, D-1, D-1) %*% diag(1/sigma_diag) diag(rho) <- 1 rho #>           [,1]      [,2] #> [1,] 1.0000000 0.1857594 #> [2,] 0.1857594 1.0000000   #We define the covariate $\\boldsymbol{x}$ and also, the corresponding betas, constructing the corresponding linear predictor. xx <- runif(N)-0.5 data$xx <- xx   # - mean 0 to not affect intercept X <- data.frame(xx) %>% as.matrix(.)   #Spatial effects. Two different random fields spatial <- fm_evaluate(   mesh_fine,   loc = as.matrix(data),   field = true_field )  #Linear predictors lin.pred <- X %*% t(betas) + spatial"},{"path":"/articles/simulations.html","id":"alr-coordinates","dir":"Articles","previous_headings":"Simulating a dataset with replicate random effects","what":"alr-coordinates","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"construct alralr-coordinates","code":"Sigma <- matrix(sigma_diag, ncol = 1) %*% matrix(sigma_diag, nrow = 1) Sigma <- Sigma*rho  lin.pred %>%   apply(., 1, function(z)     MASS::mvrnorm( n  = 1,                    mu = z,                    Sigma = Sigma)) %>%   t(.)-> alry colnames(alry) <- paste0(\"alr.y\", (1:(D-1)))"},{"path":"/articles/simulations.html","id":"data-in-the-simplex","dir":"Articles","previous_headings":"Simulating a dataset with replicate random effects","what":"Data in the simplex","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"move back Simplex using alralr-inverse, particular, use function alrInv form R-package compositions.","code":"y.simplex <- compositions::alrInv(alry) y.simplex <- as.numeric(t(y.simplex)) %>% matrix(., ncol = D, byrow = TRUE) colnames(y.simplex) <- paste0(\"y\", 1:D) data <- cbind(data, alry, y.simplex) data %>% head(.) #>        lon       lat          xx       alr.y1     alr.y2        y1         y2 #> 1 2.164178 7.5629924 -0.33326109 -0.846303168  2.4042713 0.0343216 0.88567429 #> 2 8.344236 7.7793818 -0.04749689  0.399583098 -0.5431795 0.4854016 0.18908828 #> 3 7.513832 8.1528313 -0.49554979 -0.752270018  0.1622192 0.1780211 0.44425174 #> 4 4.060105 0.2253018  0.45511586  0.052528066 -3.3525703 0.5045329 0.01675229 #> 5 9.710200 2.8148251  0.49812543  2.512558663 -1.8879415 0.9146355 0.01122368 #> 6 1.123315 1.1945009  0.16154746 -0.001549842 -2.6863049 0.4831410 0.03296853 #>           y3 #> 1 0.08000411 #> 2 0.32551011 #> 3 0.37772716 #> 4 0.47871480 #> 5 0.07414087 #> 6 0.48389042"},{"path":"/articles/simulations.html","id":"plotting-the-response","dir":"Articles","previous_headings":"Simulating a dataset with replicate random effects","what":"Plotting the response","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"bound <- fortify(bnd) #> Warning: `fortify(<SpatialPolygonsDataFrame>)` was deprecated in ggplot2 3.4.4. #> ‚Ñπ Please migrate to sf. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Regions defined for each Polygons data_plot <- data %>%   dplyr::select(all_of(c(\"lon\", \"lat\", paste0(\"y\", 1:D)))) %>%   tidyr::pivot_longer(all_of(paste0(\"y\", 1:D)))   p1 <- ggplot() +   geom_polygon(data = bound, aes(x = long,                                  y = lat),                colour = 'gray70', fill = 'gray90') +   geom_point(data = data_plot,              aes(x = lon,                  y = lat,                  #size = value,                  color = value),              alpha = 0.8, size = 3) +   coord_fixed(ratio = 1) +   facet_wrap(~ name, ncol = 4) +   theme_bw() +   theme(line = element_blank(),                          # remove axis lines ..         axis.text = element_blank(),                       # .. tickmarks..         axis.title = element_blank(),         panel.background = element_blank(),         legend.position = \"bottom\",         legend.key.height = unit(0.5, \"cm\"),         legend.key.width = unit(1.5, \"cm\"),         legend.title = element_text(size = 17),         legend.text = element_text(size = 15),         strip.text = element_text(size = 15)) +   #guides(fill = guide_legend(title.position=\"top\", title.hjust = 0.5)) +   xlab(\"\") +   ylab(\"\") +   scale_color_viridis(option=\"magma\", direction = -1, limits = c(0, 1),                       name = \"\") getwd() #> [1] \"/home/runner/work/INLAcomp/INLAcomp/vignettes\"  #pdf(\"simulation_data.pdf\", width = 10, height = 5) print(p1) #dev.off()"},{"path":"/articles/simulations.html","id":"plotting-the-alr-coordiantes","dir":"Articles","previous_headings":"Simulating a dataset with replicate random effects","what":"Plotting the alr-coordiantes","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"data_plot_alr <- data %>%     dplyr::select(all_of(c(\"lon\", \"lat\", paste0(\"alr.y\", 1:(D-1))))) %>%     tidyr::pivot_longer(all_of(paste0(\"alr.y\", 1:(D-1))))     #Plotting the map   p2 <- ggplot() +     geom_polygon(data = bound, aes(x = long,                                    y = lat),                  colour = 'gray70', fill = 'gray90') +     geom_point(data = data_plot_alr,                aes(x = lon,                    y = lat,                    #size = value,                    color = value),                alpha = 0.8, size = 3) +     coord_fixed(ratio = 1) +     facet_wrap(~ name) +     theme_bw() +     theme(line = element_blank(),                          # remove axis lines ..           axis.text = element_blank(),                       # .. tickmarks..           axis.title = element_blank(),           panel.background = element_blank(),           legend.position = \"bottom\",           legend.key.height = unit(0.5, \"cm\"),           legend.key.width = unit(1.5, \"cm\"),           legend.title = element_text(size = 17),           legend.text = element_text(size = 15),           strip.text = element_text(size = 15)) +     #guides(fill = guide_legend(title.position=\"top\", title.hjust = 0.5)) +     xlab(\"\") +     ylab(\"\") +     scale_color_viridis(option=\"magma\", direction = -1,                         name = \"\") #pdf(\"simulation_data_alr.pdf\", width = 9, height = 5)   print(p2) #dev.off()"},{"path":[]},{"path":"/articles/simulations.html","id":"defining-a-new-column-with-the-values-of-all-alr-coordinates","dir":"Articles","previous_headings":"Preparing the data for fitting","what":"Defining a new column with the values of all alr coordinates","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"names_gc <- paste0(\"y\", 1:(D-1)) data_ext <- data %>%   tidyr::pivot_longer(., cols = all_of(paste0(\"alr.\", names_gc)),                       names_to  = \"alr_gc\",                       values_to = \"val_alr_gc\") %>%   .[order(ordered(.$alr_gc)),] head(data_ext[, c(\"lon\", \"lat\", \"alr_gc\", \"val_alr_gc\")]) #> # A tibble: 6 √ó 4 #>     lon   lat alr_gc val_alr_gc #>   <dbl> <dbl> <chr>       <dbl> #> 1  2.16 7.56  alr.y1   -0.846   #> 2  8.34 7.78  alr.y1    0.400   #> 3  7.51 8.15  alr.y1   -0.752   #> 4  4.06 0.225 alr.y1    0.0525  #> 5  9.71 2.81  alr.y1    2.51    #> 6  1.12 1.19  alr.y1   -0.00155"},{"path":"/articles/simulations.html","id":"defining-index-for-indiciating-which-alr-coordinate-are-we-dealing-with","dir":"Articles","previous_headings":"Preparing the data for fitting","what":"Defining index for indiciating which alr-coordinate are we dealing with","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"data_ext$alr_gc <- ordered(data_ext$alr_gc) k.group <- data_ext$alr_gc %>% as.numeric() #For group k.repl  <- data_ext$alr_gc %>% as.numeric() #For replication head(data.frame(k.group, k.repl)) #>   k.group k.repl #> 1       1      1 #> 2       1      1 #> 3       1      1 #> 4       1      1 #> 5       1      1 #> 6       1      1"},{"path":"/articles/simulations.html","id":"the-mesh","dir":"Articles","previous_headings":"Preparing the data for fitting","what":"The mesh","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"create mesh usually R-INLA spatial effects.","code":"mesh <- inla.mesh.2d(boundary = bnd,                      max.edge = 0.5,                      cutoff   = 0.1,                      min.angle= 30,                      offset   = c(0.2, 2)) ggplot() +   gg(mesh) +   coord_equal() +   geom_point(data = data,              aes(x = lon, y = lat))"},{"path":[]},{"path":"/articles/simulations.html","id":"defining-spde-with-priors","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the spde","what":"Defining spde with priors","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"use PC-priors defining spde object.","code":"size <- 10 range0 <- size / 4  # ~ default spde <- inla.spde2.pcmatern(mesh        = mesh,                             prior.range = c(range0, 0.25), # P(range < range0) = 0.25                             prior.sigma = c(1, 0.01)) # P(sigma > 1) = 0.01"},{"path":"/articles/simulations.html","id":"index-for-the-spatial-effects","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the spde","what":"Index for the spatial effects","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"distinguish copy spatial effect replicate .","code":""},{"path":"/articles/simulations.html","id":"spatial-index-to-be-used-in-the-model--we-define-it-by-alr-coordinate","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the spde > Index for the spatial effects","what":"Spatial index to be used in the model. We define it by alr-coordinate","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"spatial index useful replicate spatial effects, words, one spatial effect per linear predictor whose realizations different hyperparameters equal.","code":"iset <- inla.spde.make.index('i', n.spde = spde$n.spde,                              n.repl  = k-1) #Replicating spatial effect"},{"path":"/articles/simulations.html","id":"this-iset-is-for-copy","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the spde > Index for the spatial effects","what":"This iset is for copy","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"spatial index useful copy spatial effects, words, one spatial effect per linear predictor whose realizations equal proportionally equivalente, hyperparameters equal.","code":"iset2 <- inla.spde.make.index('i', n.spde = spde$n.spde) iset_aux <- matrix(NA, ncol = k-1, nrow = k-1) diag(iset_aux) <- rep(1, k-1) iset2 <- kronecker(iset_aux, iset2$i) colnames(iset2) <- paste0(\"iset.alr\", 1:(k-1))"},{"path":"/articles/simulations.html","id":"defining-the-projection-matrix","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the spde","what":"Defining the projection matrix","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"A.est <- inla.spde.make.A(mesh  = mesh,                           loc   = cbind(data_ext$lon, data_ext$lat),                           repl  = k.repl) A.est2 <- A.est"},{"path":[]},{"path":"/articles/simulations.html","id":"index-for-the-random-effect-that-is-going-to-give-the-correlation","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the corresponding part to the shared random effect","what":"Index for the random effect that is going to give the correlation","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"id.z <- rep(1:(dim(data_ext)[1]/(k-1)), k-1)"},{"path":"/articles/simulations.html","id":"index-for-indicating-the-alr-coordinate","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the corresponding part to the shared random effect","what":"Index for indicating the alr coordinate","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"id.cat <- rep(1:(k-1), rep(N, k-1))"},{"path":[]},{"path":"/articles/simulations.html","id":"response","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the inla.stack","what":"Response","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"define list three elements (three alr-coordinates) format R-INLA uses deal several likelihoods.","code":"#Response names_alr <- paste0(\"alr.\", names_gc)   1:length(names_alr) %>%   lapply(., function(i){     data_ext %>%       dplyr::filter(alr_gc == names_alr[i]) -> data_comp_i     #Response     y_alr <- matrix(ncol = names_alr %>% length(.), nrow = dim(data_comp_i)[1])     y_alr[, i] <- data_comp_i$val_alr_gc   }) -> y_alr  1:length(names_alr) %>%   lapply(., function(i){     y_aux <- data_ext %>%       dplyr::select(val_alr_gc, alr_gc) %>%       dplyr::filter(alr_gc == names_alr[i]) %>%       dplyr::select(val_alr_gc) %>%       as.matrix(.)     aux_vec <- rep(NA, k-1)     aux_vec[i] <- 1     kronecker(aux_vec, y_aux)   }) -> y_alr_list  y_alr <- do.call(cbind, y_alr_list) y_alr[1:10,] #>               [,1] [,2] #>  [1,] -0.846303168   NA #>  [2,]  0.399583098   NA #>  [3,] -0.752270018   NA #>  [4,]  0.052528066   NA #>  [5,]  2.512558663   NA #>  [6,] -0.001549842   NA #>  [7,]  1.164093794   NA #>  [8,]  2.047636770   NA #>  [9,]  0.564710978   NA #> [10,]  1.064159558   NA"},{"path":"/articles/simulations.html","id":"covariates","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the inla.stack","what":"Covariates","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Covariates going included model random effects big variance. , need values covariates (scaled one), also, index indicating alr-coordinate belongs.","code":"variables <- c(\"intercept\", data %>%                  dplyr::select(xx) %>%                  colnames(.)) id.names <- paste0(\"id.\", variables) id.variables <- rep(id.cat, length(variables)) %>%   matrix(., ncol = length(variables), byrow = FALSE) colnames(id.variables) <- id.names"},{"path":"/articles/simulations.html","id":"inla-stack-for-estimation","dir":"Articles","previous_headings":"Preparing the data for fitting > Defining the inla.stack","what":"Inla stack for estimation","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"stk.est <- inla.stack(data    = list(resp = y_alr),                       A       = list(A.est, 1, A.est2),                       effects = list(c(iset),                                      cbind(data_ext %>%                                              dplyr::select(starts_with(\"xx\")),                                            id.z,                                            id.variables,                                            intercept = 1),                                      data.frame(iset2)),                       tag     = 'est')"},{"path":[]},{"path":"/articles/simulations.html","id":"type-i","dir":"Articles","previous_headings":"Fitting the different models","what":"Type I","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Share parameters fixed effects, include spatial random e‚Üµects.","code":"list_prior <- rep(list(list(prior = \"pc.prec\", param = c(1, 0.01))), k-1)  formula.typeI <- resp ~ -1 +    xx +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))), constr = TRUE)  model.typeI <- inla(formula.typeI,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                       verbose = FALSE)"},{"path":"/articles/simulations.html","id":"type-ii","dir":"Articles","previous_headings":"Fitting the different models","what":"Type II","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"different parameters fixed effects, include spatial random e‚Üµects.","code":"formula.typeII <- resp ~ -1 +    f(id.xx, xx, #BIO1     model   = \"iid\",     initial = log(1/10000),     fixed   = TRUE) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))), constr = TRUE)  model.typeII <- inla(formula.typeII,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                       verbose = FALSE)"},{"path":"/articles/simulations.html","id":"type-iii","dir":"Articles","previous_headings":"Fitting the different models","what":"Type III","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Share parameters fixed effects, share spatial effect.","code":"formula.typeIII <- resp ~ -1 +    xx +   f(iset.alr1, model = spde) +   f(iset.alr2, copy = \"iset.alr1\",      fixed = TRUE) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))), constr = TRUE)  model.typeIII <- inla(formula.typeIII,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                       verbose = FALSE)"},{"path":"/articles/simulations.html","id":"type-iv","dir":"Articles","previous_headings":"Fitting the different models","what":"Type IV","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"different parameters fixed effects, share spatial effect.","code":"list_prior <- rep(list(list(prior = \"pc.prec\", param = c(1, 0.01))), k-1)  formula.typeIV <- resp ~ -1 +    f(id.xx, xx,      model   = \"iid\",     initial = log(1/10000),     fixed   = TRUE) +   f(iset.alr1, model = spde) +   f(iset.alr2, copy = \"iset.alr1\",      fixed = TRUE) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))),     constr = TRUE)  model.typeIV <- inla(formula.typeIV,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                       verbose = FALSE)"},{"path":"/articles/simulations.html","id":"type-v","dir":"Articles","previous_headings":"Fitting the different models","what":"Type V","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Share parameters fixed effects, spatial effects linear predictors proportional.","code":"formula.typeV <- resp ~ -1 +    xx +   f(iset.alr1, model = spde) +   f(iset.alr2, copy = \"iset.alr1\",      fixed = FALSE) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))), constr = TRUE)  model.typeV <- inla(formula.typeV,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                       verbose = FALSE)"},{"path":"/articles/simulations.html","id":"type-vi","dir":"Articles","previous_headings":"Fitting the different models","what":"Type VI","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"different parameters fixed effects, spatial effects linear predictors proportional","code":"list_prior <- rep(list(list(prior = \"pc.prec\", param = c(1, 0.01))), k-1)  formula.typeVI <- resp ~ -1 +    f(id.xx, xx, #xx     model   = \"iid\",     initial = log(1/10000),     fixed   = TRUE) +   f(iset.alr1, model = spde) +   f(iset.alr2, copy = \"iset.alr1\",     hyper = list(beta = list(fixed = FALSE, params = c(0, 1)))) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))),     constr = TRUE)    model.typeVI <- inla(formula.typeVI,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                      verbose = FALSE)  #model.typeVI <- inla.rerun(model.typeVI)"},{"path":"/articles/simulations.html","id":"type-vii","dir":"Articles","previous_headings":"Fitting the different models","what":"Type VII","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"Share parameters fixed effects, different realisations spatial effect linear predictor","code":"formula.typeVII <- resp ~ -1 +    xx +   f(i,     model = spde,     replicate = i.repl) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))), constr = TRUE)  model.typeVII <- inla(formula.typeVII,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                       inla.mode = \"experimental\" ,                     verbose = FALSE)"},{"path":"/articles/simulations.html","id":"type-viii","dir":"Articles","previous_headings":"Fitting the different models","what":"Type VIII","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"different parameters fixed effects, different realisations spatial effect linear predictor","code":"list_prior <- rep(list(list(prior = \"pc.prec\", param = c(1, 0.01))), k-1)  formula.typeVIII <- resp ~ -1 +    f(id.xx, xx, #xx     model   = \"iid\",     initial = log(1/10000),     fixed   = TRUE) +   f(i,     model = spde,     replicate = i.repl) +   f(id.z,     model = \"iid\",     hyper = list(prec = list(prior = \"pc.prec\",                              param = c(1, 0.01))), constr = TRUE)  model.typeVIII <- inla(formula.typeVIII,                    family         = rep(\"gaussian\", k - 1),                    data           = inla.stack.data(stk.est),                    control.compute = list(config = TRUE,                                            dic  = TRUE,                                           waic = TRUE,                                           cpo  = TRUE),                    control.predictor = list(A = inla.stack.A(stk.est),                                              compute = TRUE),                    control.family = list_prior,                       verbose = FALSE)"},{"path":"/articles/simulations.html","id":"comparing-using-dic-waic-and-lcpo","dir":"Articles","previous_headings":"","what":"Comparing using DIC, WAIC and LCPO","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"tutorial, moment, compute DIC, WAIC LCPO models. DIC WAIC: obtain joint posterior distribution model using inla.posterior.sample function. use functions dic.mult waic.mult computing new DIC WAIC. CPO: define friends dataset. use function inla.group.cv argument num.level.sets = -1 computing CPO.","code":"model_list <- list(model.typeI,                model.typeII,                model.typeIII,                model.typeIV,                model.typeV,                model.typeVI,                model.typeVII,                model.typeVIII)  names(model_list) <- paste0(\"type\", c(\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\"))  ## Computing measures of this model measures <- lapply(model_list, function(mod1){   xx <- inla.posterior.sample(1000, mod1, seed = inla.seed)   inf <- parallel::mclapply(xx, INLAcomp::extract_lp_sigma)      #DIC   dic.mod1 <- INLAcomp::dic.mult(inf, y = data[, c(paste0(\"alr.y\", 1:(k-1)))])      #WAIc   waic.mod1 <- INLAcomp::waic.mult(inf, y = data[, c(paste0(\"alr.y\", 1:(k-1)))])      #lIST FOR cpo   friends_list <- 1:(N*(D-1)) %>%   lapply(., function(x){     c(seq(x, N*(D-1), by = N)[-1],       rev(seq(x, 1, by = -N))) -> res     res[order(res)]   })             a4 <- INLA::inla.group.cv(result = mod1,                           num.level.sets = -1,                           strategy = \"posterior\",                           friends = friends_list,                           verbose = FALSE)    LCPO <- a4$cv %>% log(.) %>% mean(.) %>% -.    data.frame(DIC = dic.mod1, WAIC = waic.mod1, LCPO = LCPO)    }) #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1' #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1' #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1' #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1' #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1' #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1' #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1' #> Warning in inla.posterior.sample(n, rfake, intern = intern, use.improved.mean = #> use.improved.mean, : Since 'seed!=0', parallel model is disabled and serial #> model is selected, num.threads='1:1'  measures <-  as.data.frame(do.call(rbind, measures))  xtable::xtable(measures[, c(\"DIC.dic\", \"WAIC.waic\", \"LCPO\")], digits = 3) #> % latex table generated in R 4.4.1 by xtable 1.8-4 package #> % Fri Sep 20 15:10:59 2024 #> \\begin{table}[ht] #> \\centering #> \\begin{tabular}{rrrr} #>   \\hline #>  & DIC.dic & WAIC.waic & LCPO \\\\  #>   \\hline #> typeI & 7326.280 & 7326.363 & 1.830 \\\\  #>   typeII & 6920.997 & 6921.282 & 1.729 \\\\  #>   typeIII & 6598.360 & 6585.401 & 1.642 \\\\  #>   typeIV & 6193.747 & 6174.297 & 1.536 \\\\  #>   typeV & 6564.553 & 6574.572 & 1.643 \\\\  #>   typeVI & 5697.063 & 5694.244 & 1.595 \\\\  #>   typeVII & 5792.595 & 5804.340 & 1.452 \\\\  #>   typeVIII & 4719.775 & 4738.928 & 1.183 \\\\  #>    \\hline #> \\end{tabular} #> \\end{table}"},{"path":[]},{"path":"/articles/simulations.html","id":"recovering-spatial-random-fields","dir":"Articles","previous_headings":"Checking posterior distributions of the best model","what":"Recovering spatial random fields","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"represent median credible intervals 95% spatial random fields.","code":"model <- model.typeVIII spatial_median <- raster_spatial_effect(spatial = model$summary.random[['i']][['0.5quant']],                                       boundary = raster_predict,                                       boundary1 = bnd)  spatial_q.025 <- raster_spatial_effect(spatial = model$summary.random[['i']][[\"0.025quant\"]],                                          boundary = raster_predict,                                          boundary1 = bnd)  spatial_q.975 <- raster_spatial_effect(spatial = model$summary.random[['i']][[\"0.975quant\"]],                                          boundary = raster_predict,                                          boundary1 = bnd)  range.sp1 <- range(c(values(spatial_median[[1]]), values(truth_r[[1]]),                    values(spatial_q.975[[1]]), values(spatial_q.025[[1]]))) range.sp2 <- range(c(values(spatial_median[[2]]), values(truth_r[[2]]),                    values(spatial_q.975[[2]]), values(spatial_q.025[[2]]))) #Plotting p1.alr1.Real <- plot_raster(rast = truth_r,                             ymin = range.sp1[1], ymax = range.sp1[2],                             poly = bnd,                             cat = 1,                             names = \"alr.y1-Real\",                             legkeywidth = 2) #> Regions defined for each Polygons    p1.alr1.median <- plot_raster(rast = spatial_median,                             ymin = range.sp1[1], ymax = range.sp1[2],                             poly = bnd,                             cat = 1,                             names = \"alr.y1-Median\",                             legkeywidth = 2) #> Regions defined for each Polygons  p1.alr1.025 <- plot_raster(rast = spatial_q.025,                             ymin = range.sp1[1], ymax = range.sp1[2],                             poly = bnd,                             cat = 1,                             names = \"alr.y1-Q0.025\",                             legkeywidth = 2) #> Regions defined for each Polygons  p1.alr1.975 <- plot_raster(rast = spatial_q.975,                             ymin = range.sp1[1], ymax = range.sp1[2],                             poly = bnd,                             cat = 1,                             names = \"alr.y1-Q0.975\",                             legkeywidth = 2) #> Regions defined for each Polygons  ## alr2 p1.alr2.Real <- plot_raster(rast = truth_r,                             ymin = range.sp2[1], ymax = range.sp2[2],                             poly = bnd,                             cat = 2,                             names = \"alr.y2-Real\",                             legkeywidth = 2) #> Regions defined for each Polygons  p1.alr2.median <- plot_raster(rast = spatial_median,                             ymin = range.sp2[1], ymax = range.sp2[2],                             poly = bnd,                             cat = 2,                             names = \"alr.y2-Median\",                             legkeywidth = 2) #> Regions defined for each Polygons   p1.alr2.025 <- plot_raster(rast = spatial_q.025[[2]],                            ymin = range.sp2[1], ymax = range.sp2[2],                            poly = bnd,                            cat = 1,                            names = \"alr.y2-Q0.025\",                            legkeywidth = 2) #> Regions defined for each Polygons  p1.alr2.975 <- plot_raster(rast = spatial_q.975[[2]],                             ymin = range.sp2[1], ymax = range.sp2[2],                             poly = bnd,                             cat = 1,                             names = \"alr.y2-Q0.975\",                             legkeywidth = 2) #> Regions defined for each Polygons  mylegend_alr1 <- g_legend(p1.alr1.Real) mylegend_alr2 <- g_legend(p1.alr2.Real)   gridExtra::grid.arrange(gridExtra::arrangeGrob(p1.alr1.Real + theme(legend.position = \"none\"),                                     p1.alr1.median + theme(legend.position = \"none\"),                                     p1.alr1.025 + theme(legend.position = \"none\"),                                     p1.alr1.975 + theme(legend.position = \"none\"),                                     nrow = 1),                         gridExtra::arrangeGrob(mylegend_alr1,                                     nrow = 1, widths = c(4)),                         gridExtra::arrangeGrob(p1.alr2.Real + theme(legend.position = \"none\"),                                     p1.alr2.median + theme(legend.position = \"none\"),                                     p1.alr2.025 + theme(legend.position = \"none\"),                                     p1.alr2.975 + theme(legend.position = \"none\"),                                     nrow = 1),                         gridExtra::arrangeGrob(mylegend_alr2, nrow = 1, widths = c(4)),                         nrow = 4, ncol = 1, heights = c(6, 1, 6, 1)) #png(paste0(\"spatial\",\"_\", N, \".png\"), width = 1400, height = 1050, res = 150)"},{"path":"/articles/simulations.html","id":"recovering-corresponding-to-the-fixed-effects","dir":"Articles","previous_headings":"Checking posterior distributions of the best model","what":"Recovering corresponding to the fixed effects","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"lapply(1:(D-1), function(xx){   data.frame(inla.smarginal(model$marginals.random$id.xx[[xx]]),              alr = paste0(\"(\", xx, \")\"),              var = \"beta1\") }) %>% do.call(rbind.data.frame, .) -> data_fixed2 #data_fixed <- rbind(data_fixed, data_fixed2) data_fixed <- data_fixed2 data_fixed$alrvar = data_fixed$alr  fixed.real <- data.frame(real = c(as.numeric((betas))),                          alrvar = c(                          paste0(\"(\", 1:(D-1), \")\")))    p.fixed <- ggplot() +   geom_line(data = data_fixed, aes(x = x, y = y), size = 0.9) +   geom_vline(data = fixed.real, aes(xintercept = real), col = \"red4\") +   theme_bw() +   theme(legend.position = \"bottom\") +   facet_wrap(~ alrvar, nrow = 1, scales = \"free\",                labeller = label_bquote(beta [1] ^ .(alrvar))) +   xlab(expression(beta^(d))) +   ylab(expression(p(beta^(d) *'|'* theta))) +   theme(legend.title = element_blank()) #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ‚Ñπ Please use `linewidth` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated.  #pdf(\"posterior_fixed.pdf\", width = 6, height = 5) print(p.fixed) #dev.off()"},{"path":"/articles/simulations.html","id":"recovering-hyperparameters","dir":"Articles","previous_headings":"Checking posterior distributions of the best model","what":"Recovering hyperparameters","title":"Fitting CoDa using the Logistic Gaussian distribution with Dirichlet covariance structure. An spatial simulation example","text":"","code":"prec <- model$marginals.hyperpar[1:(D-1)] %>%   c(., list(model$marginals.hyperpar$`Precision for id.z`))  hyper <- lapply(1:length(prec),                 function(x){                   inla.smarginal(inla.tmarginal(prec[[x]], fun = function(y)(1/y))) %>%                     data.frame(.)                 }) names(hyper) <- c(paste0(\"sigma2.\", 1:(D-1)), \"gamma\")  hyper <- c(hyper,            sigma.sp = list(inla.smarginal(model$marginals.hyperpar[[\"Stdev for i\"]])),            phi = list(inla.smarginal(model$marginals.hyperpar[[\"Range for i\"]]))) hyper.df <- lapply(1:length(hyper),                    function(x){                      cbind(data.frame(hyper[[x]]), name1 = names(hyper)[x])                    })  %>%   do.call(rbind.data.frame, .)  hyper.df$name1 <- ordered(hyper.df$name1,                           levels = c(paste0(\"sigma2.\", 1:(D-1)),                                      \"gamma\", \"phi\", \"sigma.sp\")) #hyper.df$name1 <- as.character(hyper.df$name1)   hyper.df$name1 <- ordered(hyper.df$name1,                           levels = c(\"sigma2.1\", \"sigma2.2\",                                      \"gamma\", \"phi\", \"sigma.sp\"),                           labels = c(\"sigma[1]^2\", \"sigma[2]^2\", \"gamma\", \"phi\", \"sigma[w]\"))   hyper.real <- data.frame(real = c(sigma2, cov_param, true_range, true_sigma),                          name1 = c(paste0(\"sigma2.\", 1:(D-1)),                                    \"gamma\", \"phi\", \"sigma.sp\"))  hyper.real$name1 <- as.factor(hyper.real$name1) hyper.real$name1 <- ordered(hyper.real$name1,                           levels = c(\"sigma2.1\", \"sigma2.2\",                                      \"gamma\", \"phi\", \"sigma.sp\"),                           labels = c(\"sigma[1]^2\", \"sigma[2]^2\", \"gamma\", \"phi\", \"sigma[w]\"))    p.hyper <- ggplot(hyper.df) +   geom_line(aes(x = x, y = y)) +   geom_vline(data = hyper.real, aes(xintercept = real), col = \"red4\") +   facet_wrap(~ name1, scales = \"free\",               labeller = label_parsed) +   theme_bw() +   xlab(expression(theta)) +   ylab(expression(p(theta*'|'*y)))  #pdf(\"simulation_data_hyperpar.pdf\", width = 9, height = 5) print(p.hyper) #dev.off()"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joaqu√≠n Mart√≠nez-Minaya. Author, maintainer, contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Joaqu√≠n Mart√≠nez-Minaya (2024). INLAcomp: Logistic-normal Dirichlet Model Compositional Data. R package version 0.2.0, https://jmartinez-minaya.github.io/INLAcomp/.","code":"@Manual{,   title = {INLAcomp: Logistic-normal Dirichlet Model for Compositional Data},   author = {{Joaqu√≠n Mart√≠nez-Minaya}},   year = {2024},   note = {R package version 0.2.0},   url = {https://jmartinez-minaya.github.io/INLAcomp/}, }"},{"path":"/index.html","id":"inlacomp","dir":"","previous_headings":"","what":"Logistic-normal Dirichlet Model for Compositional Data","title":"Logistic-normal Dirichlet Model for Compositional Data","text":"goal INLAcomp analyze compositional data Logistic Normal distribution regression Dirichlet residuals (LNDM) using integrated nested Laplace approximation via R-INLA package. Method Martinez-Minaya Rue, 2024. tutorial fit simple LNDM model using R-INLA, click Spatial LNDM simulation conducted paper available . generated html availabe code Real example depicted paper available vignette. generated html available ","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Logistic-normal Dirichlet Model for Compositional Data","text":"yet CRAN, can install latest bugfix release INLAcomp github :","code":"remotes::install_github(\"https://github.com/jmartinez-minaya/INLAcomp\")"},{"path":"/reference/dic.mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing dic for a Multivariate Gaussian likelihood ‚Äî dic.mult","title":"Computing dic for a Multivariate Gaussian likelihood ‚Äî dic.mult","text":"`dic.mult` computes DIC Multivariate Gaussian likelihood","code":""},{"path":"/reference/dic.mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing dic for a Multivariate Gaussian likelihood ‚Äî dic.mult","text":"","code":"dic.mult(inf, y)"},{"path":"/reference/dic.mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing dic for a Multivariate Gaussian likelihood ‚Äî dic.mult","text":"inf list nsim elements. element list result applying extract_lp_sigma. y matrix N x D response variable.","code":""},{"path":"/reference/dic.mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing dic for a Multivariate Gaussian likelihood ‚Äî dic.mult","text":"e.dev, dev.e, p.eff, dic","code":""},{"path":"/reference/dic.mult.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computing dic for a Multivariate Gaussian likelihood ‚Äî dic.mult","text":"Joaqu√≠n Mart√≠nez-Minaya <jmarminaya@gmail.com>","code":""},{"path":"/reference/dmnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing multivariate Gaussian density ‚Äî dmnorm","title":"Computing multivariate Gaussian density ‚Äî dmnorm","text":"`dmnorm` computes multivariate joint density Gaussian distribution","code":""},{"path":"/reference/dmnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing multivariate Gaussian density ‚Äî dmnorm","text":"","code":"dmnorm(y, mu, Sigma, log1 = FALSE)"},{"path":"/reference/dmnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing multivariate Gaussian density ‚Äî dmnorm","text":"y vector (1 x d) matrix (n x d) multivariate observations mu vector (1 x d) matrix (n x d) multivariate observations Sigma variance-covariance matrix (n x d) log1 TRUE logaritmith transformation used. Default FALSE.","code":""},{"path":"/reference/dmnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing multivariate Gaussian density ‚Äî dmnorm","text":"Multivariate joint density Gaussian distribution","code":""},{"path":"/reference/dmnorm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computing multivariate Gaussian density ‚Äî dmnorm","text":"Joaqu√≠n Mart√≠nez-Minaya <jmarminaya@gmail.com>","code":""},{"path":"/reference/extract_lp_sigma.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting posterior distribution of the linear predictor a of the covariance matrix from an object obtained from inla.posterior.sample ‚Äî extract_lp_sigma","title":"Extracting posterior distribution of the linear predictor a of the covariance matrix from an object obtained from inla.posterior.sample ‚Äî extract_lp_sigma","text":"`extract_lp_sigma` Extracts posterior distribution linear predictor covariance matrix object obtained inla.posterior.sample","code":""},{"path":"/reference/extract_lp_sigma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting posterior distribution of the linear predictor a of the covariance matrix from an object obtained from inla.posterior.sample ‚Äî extract_lp_sigma","text":"","code":"extract_lp_sigma(xx)"},{"path":"/reference/extract_lp_sigma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting posterior distribution of the linear predictor a of the covariance matrix from an object obtained from inla.posterior.sample ‚Äî extract_lp_sigma","text":"xx resulting object applying function `inla.posterior.sample`","code":""},{"path":"/reference/extract_lp_sigma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracting posterior distribution of the linear predictor a of the covariance matrix from an object obtained from inla.posterior.sample ‚Äî extract_lp_sigma","text":"list two objects: 1. Linear predictor substracting id.z. 2. Posterior Covariance matrix","code":""},{"path":"/reference/extract_lp_sigma.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extracting posterior distribution of the linear predictor a of the covariance matrix from an object obtained from inla.posterior.sample ‚Äî extract_lp_sigma","text":"Joaqu√≠n Mart√≠nez-Minaya <jmarminaya@gmail.com>","code":""},{"path":"/reference/waic.mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing waic for a Multivariate Gaussian likelihood ‚Äî waic.mult","title":"Computing waic for a Multivariate Gaussian likelihood ‚Äî waic.mult","text":"`waic.mult` computes WAIC Multivariate Gaussian likelihood","code":""},{"path":"/reference/waic.mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing waic for a Multivariate Gaussian likelihood ‚Äî waic.mult","text":"","code":"waic.mult(inf, y)"},{"path":"/reference/waic.mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing waic for a Multivariate Gaussian likelihood ‚Äî waic.mult","text":"inf list nsim elements. element list result applying extract_lp_sigma. y matrix N x D response variable.","code":""},{"path":"/reference/waic.mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing waic for a Multivariate Gaussian likelihood ‚Äî waic.mult","text":"p.eff.waic, waic","code":""},{"path":"/reference/waic.mult.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computing waic for a Multivariate Gaussian likelihood ‚Äî waic.mult","text":"Joaqu√≠n Mart√≠nez-Minaya <jmarminaya@gmail.com>","code":""}]
